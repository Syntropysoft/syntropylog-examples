/* eslint-disable @typescript-eslint/no-explicit-any */
/*
 * @file src/context/MockContextManager.ts
 * @description Provides a mock implementation of the IContextManager interface,
 * designed specifically for use in testing environments.
 */
/**
 * @class MockContextManager
 * @description A mock implementation of `IContextManager` for testing purposes.
 * It uses a simple in-memory object instead of AsyncLocalStorage,
 * making context management predictable and synchronous in tests.
 * @implements {IContextManager}
 */
class MockContextManager {
    /** @private The in-memory key-value store for the context. */
    store = {};
    /** @private The HTTP header name used for the correlation ID. */
    correlationIdHeader = 'x-correlation-id';
    /** @private The HTTP header name used for the transaction ID. */
    transactionIdHeader = 'x-trace-id';
    /**
     * Configures the mock context manager.
     * @param options The configuration options.
     * @param options.correlationIdHeader The custom header name to use for the correlation ID.
     * @param options.transactionIdHeader The custom header name for the transaction ID.
     */
    configure(options) {
        if (options?.correlationIdHeader) {
            this.correlationIdHeader = options.correlationIdHeader;
        }
        if (options?.transactionIdHeader) {
            this.transactionIdHeader = options.transactionIdHeader;
        }
    }
    /**
     * Simulates running a function within a new, isolated context.
     * It saves the current context, creates a new one inheriting the parent's values,
     * runs the callback, and then restores the original context. This process
     * correctly handles both synchronous and asynchronous callbacks.
     * @template T The return type of the callback.
     * @param {() => T} callback The function to execute within the new context.
     * @returns {T} The result of the callback.
     */
    async run(fn) {
        // Deep-clone the original store to ensure true isolation.
        const originalStore = JSON.parse(JSON.stringify(this.store));
        this.store = { ...this.store }; // Inherit from parent for the current run.
        try {
            // Await the callback, which might be sync or async.
            await fn();
        }
        finally {
            // Always restore the original, unmodified context.
            this.store = originalStore;
        }
    }
    /**
     * Gets a value from the mock context by its key.
     * @template T The expected type of the value.
     * @param {string} key The key of the value to retrieve.
     * @returns The value, or `undefined` if not found.
     */
    get(key) {
        return this.store[key];
    }
    /**
     * Gets a shallow copy of the entire mock context store.
     * @returns {Record<string, any>} An object containing all context data.
     */
    getAll() {
        // Return a shallow copy to prevent direct mutation of the internal store.
        return { ...this.store };
    }
    /**
     * Sets a key-value pair in the mock context.
     * @param {string} key The key for the value.
     * @param {any} value The value to store.
     * @returns {void}
     */
    set(key, value) {
        this.store[key] = value;
    }
    /**
     * Clears the in-memory store.
     * Useful for resetting state between tests (e.g., in a `beforeEach` hook).
     * @returns {void}
     */
    clear() {
        this.store = {};
    }
    /**
     * A convenience method to get the correlation ID from the mock context.
     * @returns {string | undefined} The correlation ID, or undefined if not set.
     */
    getCorrelationId() {
        // The key in the context is always 'correlationId'.
        return this.get('correlationId');
    }
    /**
     * A convenience method to get the transaction ID from the mock context.
     * @returns {string | undefined} The transaction ID, or undefined if not set.
     */
    getTransactionId() {
        // The key in the context is always 'transactionId'.
        return this.get('transactionId');
    }
    /**
     * A convenience method to set the transaction ID in the mock context.
     * @param {string} transactionId The transaction ID to set.
     */
    setTransactionId(transactionId) {
        // The key in the context is always 'transactionId'.
        this.set('transactionId', transactionId);
    }
    /**
     * Gets the configured HTTP header name used for the correlation ID.
     * @returns {string} The header name.
     */
    getCorrelationIdHeaderName() {
        return this.correlationIdHeader;
    }
    /**
     * Gets the configured HTTP header name used for the transaction ID.
     * @returns {string} The header name.
     */
    getTransactionIdHeaderName() {
        return this.transactionIdHeader;
    }
    /**
     * Mock implementation for getting trace context headers.
     * In a real tracing scenario, this would be populated.
     * @returns `undefined` as this mock does not implement tracing.
     */
    getTraceContextHeaders() {
        const headers = {};
        const correlationId = this.getCorrelationId();
        const transactionId = this.getTransactionId();
        if (correlationId) {
            headers[this.getCorrelationIdHeaderName()] = correlationId;
        }
        if (transactionId) {
            headers[this.getTransactionIdHeaderName()] = transactionId;
        }
        return headers;
    }
    getFilteredContext() {
        return this.getAll();
    }
}

/**
 * @file src/logger/levels.ts
 * @description Defines the available log levels, their names, and their severity weights.
 */
/**
 * @description A mapping of log level names to their severity weights.
 * Higher numbers indicate higher severity.
 */
const LOG_LEVEL_WEIGHTS = {
    fatal: 60,
    error: 50,
    warn: 40,
    info: 30,
    debug: 20,
    trace: 10,
    silent: 0,
};
/**
 * @description An array of the available log level names, derived from the weights object.
 */
const logLevels = Object.keys(LOG_LEVEL_WEIGHTS);

/**
 * @file src/logger/transports/Transport.ts
 * @description Defines the abstract base class for all log transports.
 */
/**
 * @class Transport
 * @description The abstract base class for all log transports. A transport is
 * responsible for the final output of a log entry, whether it's to the console,
 * a file, or a remote service.
 */
class Transport {
    level;
    name;
    /** The formatter instance to transform log entries. */
    formatter;
    /** The engine used to sanitize sensitive data. */
    sanitizationEngine;
    /**
     * @constructor
     * @param {TransportOptions} [options] - The configuration options for this transport.
     */
    constructor(options = {}) {
        this.level = options.level ?? 'info';
        this.name = options.name ?? this.constructor.name;
        this.formatter = options?.formatter;
        this.sanitizationEngine = options?.sanitizationEngine;
    }
    /**
     * Determines if the transport should process a log entry based on its log level.
     * @param level - The level of the log entry to check.
     * @returns {boolean} - True if the transport is enabled for this level, false otherwise.
     */
    isLevelEnabled(level) {
        return LOG_LEVEL_WEIGHTS[level] >= LOG_LEVEL_WEIGHTS[this.level];
    }
    /**
     * A method to ensure all buffered logs are written before the application exits.
     * Subclasses should override this if they perform I/O buffering.
     * @returns {Promise<void>} A promise that resolves when flushing is complete.
     */
    async flush() {
        // Default implementation does nothing, assuming no buffering.
        return Promise.resolve();
    }
}

/**
 * @class SpyTransport
 * A transport designed for testing. It captures log entries in memory,
 * allowing you to make assertions on what has been logged.
 * @extends {Transport}
 */
class SpyTransport extends Transport {
    entries = [];
    /**
     * @constructor
     * @param {TransportOptions} [options] - Options for the transport, such as level.
     */
    constructor(options) {
        super(options);
    }
    /**
     * Stores the log entry in an in-memory array.
     * @param {LogEntry} entry - The log entry to capture.
     * @returns {Promise<void>}
     */
    async log(entry) {
        this.entries.push(entry);
    }
    /**
     * Returns all log entries captured by this transport.
     * @returns {LogEntry[]} A copy of all captured log entries.
     */
    getEntries() {
        return [...this.entries];
    }
    /**
     * Finds log entries where the properties match the given predicate.
     * Note: This performs a shallow comparison on the entry's properties.
     * @param {Partial<LogEntry> | ((entry: LogEntry) => boolean)} predicate - An object with properties to match or a function that returns true for matching entries.
     * @returns {LogEntry[]} An array of matching log entries.
     */
    findEntries(predicate) {
        if (typeof predicate === 'function') {
            // If the predicate is a function, use it directly with filter.
            return this.entries.filter(predicate);
        }
        // If the predicate is an object, perform a shallow property comparison.
        return this.entries.filter((entry) => {
            return Object.keys(predicate).every((key) => {
                const k = key;
                return predicate[k] === entry[k];
            });
        });
    }
    /**
     * Clears all captured log entries. Call this in your test setup
     * (e.g., `beforeEach`) to ensure test isolation.
     * @returns {void}
     */
    clear() {
        this.entries = [];
    }
    /**
     * Returns the first log entry that was captured.
     * @returns {LogEntry | undefined} The first entry, or undefined if none were captured.
     */
    getFirstEntry() {
        return this.entries[0];
    }
    /**
     * Returns the most recent log entry that was captured.
     * @returns {LogEntry | undefined} The last entry, or undefined if none were captured.
     */
    getLastEntry() {
        return this.entries[this.entries.length - 1];
    }
}

/**
 * @file src/testing/index.ts
 * @description Public entry point for testing utilities.
 * This allows users to import testing tools without polluting their production bundle.
 *
 * @example
 * import { SyntropyLogTestHarness } from 'syntropylog/testing';
 */

export { MockContextManager, SpyTransport };
//# sourceMappingURL=index.mjs.map
