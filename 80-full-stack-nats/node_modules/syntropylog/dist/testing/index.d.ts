/**
 * @file src/logger/levels.ts
 * @description Defines the available log levels, their names, and their severity weights.
 */
/**
 * @description A mapping of log level names to their severity weights.
 * Higher numbers indicate higher severity.
 */
declare const LOG_LEVEL_WEIGHTS: {
    readonly fatal: 60;
    readonly error: 50;
    readonly warn: 40;
    readonly info: 30;
    readonly debug: 20;
    readonly trace: 10;
    readonly silent: 0;
};
/**
 * @description The type representing a valid log level name.
 */
type LogLevel$1 = keyof typeof LOG_LEVEL_WEIGHTS;

/**
 * @interface MaskingEngineOptions
 * @description Options for configuring the MaskingEngine.
 */
interface MaskingEngineOptions {
    /** Un array de nombres de campos sensibles. */
    fields?: (string | RegExp)[];
    /** El carácter de máscara. */
    maskChar?: string;
    /** Profundidad máxima de búsqueda. Default: 3 */
    maxDepth?: number;
    /** El estilo de enmascaramiento ('fixed' o 'preserve-length'). */
    style?: 'fixed' | 'preserve-length';
}
/**
 * @class MaskingEngine
 * A central engine responsible for applying masking rules to log metadata.
 * It recursively scans objects and masks data based on key names, and can also
 * sanitize sensitive values from URL paths. Its design is "secure-by-default,"
 * allowing for runtime configuration updates that can only add (not remove) masking rules.
 */
declare class MaskingEngine {
    /** @private A dynamic array of sensitive field names or RegExps. */
    private fieldConfigs;
    /** @private The character(s) to use for masking. */
    private readonly maskChar;
    /** @private The maximum recursion depth for masking nested objects. */
    private readonly maxDepth;
    /** @private The masking style to apply. */
    private readonly style;
    /** @private Secure regex tester with timeout. */
    private readonly regexTest;
    constructor(options?: MaskingEngineOptions);
    /**
     * Adds new sensitive fields to the masking configuration at runtime.
     * This method is "additive only" to prevent security degradation. Once a field
     * is added to the mask list, it cannot be removed during the application's lifecycle.
     *
     * @param {(string | RegExp)[]} fields - An array of new field names or RegExps to add.
     *        Duplicates are silently ignored.
     */
    addFields(fields: (string | RegExp)[]): void;
    /**
     * Processes a metadata object and applies the configured masking rules.
     * @param {Record<string, any>} meta - The metadata object to process.
     * @returns {Record<string, any>} A new object with the masked data.
     */
    process(meta: Record<string, unknown>): Promise<Record<string, unknown>>;
    /**
     * @private
     * Recursively traverses an object or array to mask data.
     * It applies two types of masking:
     * 1. **Key-based masking**: If an object key matches a rule in `fieldConfigs`, its value is masked.
     * 2. **Path-based masking**: If a string value looks like a path/URL, it's sanitized.
     *
     * @param {any} data - The data to process (can be an object, array, or primitive).
     * @param {string} currentPath - The dot-notation path of the current key.
     * @param {number} depth - The current recursion depth to prevent infinite loops.
     * @returns {any} The processed data with masking applied.
     */
    private maskRecursively;
    /**
     * @private
     * Checks if a given object key path is sensitive based on the configured rules.
     * @param {string} path - The dot-notation path of the key (e.g., "user.password").
     * @returns {Promise<boolean>} - True if the path should be masked.
     */
    private isSensitive;
    /**
     * @private
     * Sanitizes a string that may represent a URL path.
     * If a segment of the path matches a sensitive field name (case-insensitively),
     * the following path segment is completely replaced with the mask character.
     *
     * @example
     * // with `fields: ['password']`
     * sanitizeUrlPath("/api/v1/password/s3cr3t-v4lu3")
     * // returns: "/api/v1/password/*****"
     *
     * @param {string} str - The string to sanitize.
     * @returns {string} The sanitized string, or the original if no sensitive keywords were found.
     */
    private sanitizeUrlPath;
    /**
     * @private
     * Generates the appropriate mask string based on the configured style.
     * @param {any} originalValue - The original value being masked. Its length is used for 'preserve-length' style.
     * @returns {string} The generated mask string.
     */
    private getMask;
}

/**
 * @file src/sanitization/SanitizationEngine.ts
 * @description Final security layer that sanitizes log entries before they are written by a transport.
 */

/**
 * @class SanitizationEngine
 * A security engine that makes log entries safe for printing by stripping
 * potentially malicious control characters, such as ANSI escape codes.
 * This prevents log injection attacks that could exploit terminal vulnerabilities.
 */
declare class SanitizationEngine {
    private readonly maskingEngine?;
    /** @private This regex matches ANSI escape codes used for colors, cursor movement, etc. */
    private readonly ansiRegex;
    /**
     * @constructor
     * The engine is currently not configurable, but the constructor is in place for future enhancements.
     */
    constructor(maskingEngine?: MaskingEngine);
    /**
     * Processes a log metadata object, sanitizing all its string values.
     * @param {Record<string, any>} meta - The metadata object to sanitize.
     * @returns {Record<string, any>} A new, sanitized metadata object.
     */
    process(meta: Record<string, any>): Record<string, any>;
    /**
     * @private
     * Recursively traverses an object or array to sanitize all string values.
     * @param {any} data - The data to process.
     * @returns {any} The sanitized data.
     */
    private sanitizeRecursively;
}

/**
 * @file src/logger/transports/formatters/LogFormatter.ts
 * @description Defines the public contract for log entry formatters.
 */

/**
 * @interface LogFormatter
 * @description Defines the interface for a log formatter.
 * A formatter is responsible for transforming a standard LogEntry object
 * into a specific structure required by a target destination (e.g., Datadog JSON, Elastic Common Schema).
 */
interface LogFormatter {
    /**
     * Transforms a LogEntry object into a new object with the desired format.
     * @param {LogEntry} entry - The standard log entry object to be transformed.
     * @returns {Record<string, any>} A new object representing the log in the target format.
     */
    format(entry: LogEntry): Record<string, any>;
}

/**
 * @file src/logger/transports/Transport.ts
 * @description Defines the abstract base class for all log transports.
 */

/**
 * @interface TransportOptions
 * @description Defines the options for configuring a transport.
 */
interface TransportOptions {
    /**
     * The minimum log level this transport will handle.
     * If not specified, the transport will handle all levels defined by the logger.
     */
    level?: LogLevel$1;
    /**
     * An optional formatter to transform the log entry before output.
     */
    formatter?: LogFormatter;
    /**
     * An optional, pre-configured sanitization engine.
     * If provided, the transport will use it to sanitize logs. This is typically
     * used by production-safe transports like `ConsoleTransport`.
     */
    sanitizationEngine?: SanitizationEngine;
    /**
     * An optional name for the transport, useful for debugging.
     */
    name?: string;
}
/**
 * @class Transport
 * @description The abstract base class for all log transports. A transport is
 * responsible for the final output of a log entry, whether it's to the console,
 * a file, or a remote service.
 */
declare abstract class Transport {
    level: LogLevel$1;
    name: string;
    /** The formatter instance to transform log entries. */
    protected readonly formatter?: LogFormatter;
    /** The engine used to sanitize sensitive data. */
    protected readonly sanitizationEngine?: SanitizationEngine;
    /**
     * @constructor
     * @param {TransportOptions} [options] - The configuration options for this transport.
     */
    constructor(options?: TransportOptions);
    /**
     * Determines if the transport should process a log entry based on its log level.
     * @param level - The level of the log entry to check.
     * @returns {boolean} - True if the transport is enabled for this level, false otherwise.
     */
    isLevelEnabled(level: LogLevel$1): boolean;
    /**
     * The core method that all concrete transports must implement. This method
     * handles the actual sending/writing of the log entry.
     * @param {LogEntry} entry - The final, processed log entry to be outputted.
     * @returns {Promise<void>}
     */
    abstract log(entry: LogEntry): Promise<void>;
    /**
     * A method to ensure all buffered logs are written before the application exits.
     * Subclasses should override this if they perform I/O buffering.
     * @returns {Promise<void>} A promise that resolves when flushing is complete.
     */
    flush(): Promise<void>;
}

type LogLevel = 'fatal' | 'error' | 'warn' | 'info' | 'debug' | 'trace' | 'silent';
type LogEntry = {
    /** The severity level of the log. */
    level: LogLevel;
    /** The main log message, formatted from the arguments. */
    message: string;
    /** The ISO 8601 timestamp of when the log was created. */
    timestamp: string;
    /** Any other properties are treated as structured metadata. */
    [key: string]: any;
};

/**
 * @file src/logger/transports/SpyTransport.ts
 * @description A transport designed for testing purposes.
 */

/**
 * @class SpyTransport
 * A transport designed for testing. It captures log entries in memory,
 * allowing you to make assertions on what has been logged.
 * @extends {Transport}
 */
declare class SpyTransport extends Transport {
    private entries;
    /**
     * @constructor
     * @param {TransportOptions} [options] - Options for the transport, such as level.
     */
    constructor(options?: TransportOptions);
    /**
     * Stores the log entry in an in-memory array.
     * @param {LogEntry} entry - The log entry to capture.
     * @returns {Promise<void>}
     */
    log(entry: LogEntry): Promise<void>;
    /**
     * Returns all log entries captured by this transport.
     * @returns {LogEntry[]} A copy of all captured log entries.
     */
    getEntries(): LogEntry[];
    /**
     * Finds log entries where the properties match the given predicate.
     * Note: This performs a shallow comparison on the entry's properties.
     * @param {Partial<LogEntry> | ((entry: LogEntry) => boolean)} predicate - An object with properties to match or a function that returns true for matching entries.
     * @returns {LogEntry[]} An array of matching log entries.
     */
    findEntries(predicate: Partial<LogEntry> | ((entry: LogEntry) => boolean)): LogEntry[];
    /**
     * Clears all captured log entries. Call this in your test setup
     * (e.g., `beforeEach`) to ensure test isolation.
     * @returns {void}
     */
    clear(): void;
    /**
     * Returns the first log entry that was captured.
     * @returns {LogEntry | undefined} The first entry, or undefined if none were captured.
     */
    getFirstEntry(): LogEntry | undefined;
    /**
     * Returns the most recent log entry that was captured.
     * @returns {LogEntry | undefined} The last entry, or undefined if none were captured.
     */
    getLastEntry(): LogEntry | undefined;
}

/**
 * The collection of tools returned by `syntropyLog.setupTestHarness()`,
 * designed to facilitate testing of application logic that uses SyntropyLog.
 */
interface SyntropyLogTestHarness {
    /**
     * A spy transport that captures all log entries in memory.
     * Use its methods (`getEntries`, `findEntries`, `clear`) to make
     * assertions about what has been logged.
     */
    spyTransport: SpyTransport;
}

/**
 * @interface IContextManager
 * @description The contract for managing asynchronous context.
 */
interface IContextManager {
    /**
     * Configures the context manager with specific options.
     * This should be called once during initialization.
     * @param options The configuration options.
     * @param options.correlationIdHeader The custom header name to use for the correlation ID.
     * @param options.transactionIdHeader The custom header name for the transaction ID.
     */
    configure(options: any): void;
    /**
     * Executes a function within a new, isolated asynchronous context.
     * The new context can inherit data from the parent context.
     * @template T The return type of the callback function.
     * @param callback The function to execute within the new context.
     * @returns The return value of the callback function.
     */
    run(fn: () => void | Promise<void>): Promise<void>;
    /**
     * Sets a value in the current asynchronous context.
     * @param key The key for the value.
     * @param value The value to store.
     */
    set(key: string, value: any): void;
    /**
     * Gets a value from the current asynchronous context.
     * @template T The expected type of the value.
     * @param key The key of the value to retrieve.
     * @returns The value associated with the key, or `undefined` if not found.
     */
    get(key: string): any;
    /**
     * Gets the entire key-value store from the current context.
     * @returns {Record<string, any>} An object containing all context data.
     */
    getAll(): Record<string, any>;
    /**
     * A convenience method to get the correlation ID from the current context.
     * @returns {string | undefined} The correlation ID, or undefined if not set.
     */
    getCorrelationId(): string | undefined;
    /**
     * Gets the configured HTTP header name used for the correlation ID.
     * @returns {string} The header name.
     */
    getCorrelationIdHeaderName(): string;
    /**
     * Gets the configured HTTP header name used for the transaction ID.
     * @returns {string} The header name.
     */
    getTransactionIdHeaderName(): string;
    /**
     * A convenience method to get the transaction ID from the current context.
     * @returns {string | undefined} The transaction ID, or undefined if not set.
     */
    getTransactionId(): string | undefined;
    /**
     * A convenience method to set the transaction ID in the current context.
     * @param transactionId The transaction ID to set.
     */
    setTransactionId(transactionId: string): void;
    /** Gets the tracing headers to propagate the context (e.g., W3C Trace Context). */
    getTraceContextHeaders(): Record<string, string>;
    /**
     * Gets a filtered context based on the specified log level.
     * This is useful for logging purposes to ensure only relevant context is included.
     * @param level The log level to filter by.
     * @returns A record containing only the context data relevant for the specified level.
     */
    getFilteredContext(level: LogLevel): Record<string, unknown>;
}

/**
 * @class MockContextManager
 * @description A mock implementation of `IContextManager` for testing purposes.
 * It uses a simple in-memory object instead of AsyncLocalStorage,
 * making context management predictable and synchronous in tests.
 * @implements {IContextManager}
 */
declare class MockContextManager implements IContextManager {
    /** @private The in-memory key-value store for the context. */
    private store;
    /** @private The HTTP header name used for the correlation ID. */
    private correlationIdHeader;
    /** @private The HTTP header name used for the transaction ID. */
    private transactionIdHeader;
    /**
     * Configures the mock context manager.
     * @param options The configuration options.
     * @param options.correlationIdHeader The custom header name to use for the correlation ID.
     * @param options.transactionIdHeader The custom header name for the transaction ID.
     */
    configure(options?: {
        correlationIdHeader?: string;
        transactionIdHeader?: string;
    }): void;
    /**
     * Simulates running a function within a new, isolated context.
     * It saves the current context, creates a new one inheriting the parent's values,
     * runs the callback, and then restores the original context. This process
     * correctly handles both synchronous and asynchronous callbacks.
     * @template T The return type of the callback.
     * @param {() => T} callback The function to execute within the new context.
     * @returns {T} The result of the callback.
     */
    run(fn: () => void | Promise<void>): Promise<void>;
    /**
     * Gets a value from the mock context by its key.
     * @template T The expected type of the value.
     * @param {string} key The key of the value to retrieve.
     * @returns The value, or `undefined` if not found.
     */
    get<T = any>(key: string): T | undefined;
    /**
     * Gets a shallow copy of the entire mock context store.
     * @returns {Record<string, any>} An object containing all context data.
     */
    getAll(): Record<string, any>;
    /**
     * Sets a key-value pair in the mock context.
     * @param {string} key The key for the value.
     * @param {any} value The value to store.
     * @returns {void}
     */
    set(key: string, value: any): void;
    /**
     * Clears the in-memory store.
     * Useful for resetting state between tests (e.g., in a `beforeEach` hook).
     * @returns {void}
     */
    clear(): void;
    /**
     * A convenience method to get the correlation ID from the mock context.
     * @returns {string | undefined} The correlation ID, or undefined if not set.
     */
    getCorrelationId(): string | undefined;
    /**
     * A convenience method to get the transaction ID from the mock context.
     * @returns {string | undefined} The transaction ID, or undefined if not set.
     */
    getTransactionId(): string | undefined;
    /**
     * A convenience method to set the transaction ID in the mock context.
     * @param {string} transactionId The transaction ID to set.
     */
    setTransactionId(transactionId: string): void;
    /**
     * Gets the configured HTTP header name used for the correlation ID.
     * @returns {string} The header name.
     */
    getCorrelationIdHeaderName(): string;
    /**
     * Gets the configured HTTP header name used for the transaction ID.
     * @returns {string} The header name.
     */
    getTransactionIdHeaderName(): string;
    /**
     * Mock implementation for getting trace context headers.
     * In a real tracing scenario, this would be populated.
     * @returns `undefined` as this mock does not implement tracing.
     */
    getTraceContextHeaders(): Record<string, string>;
    getFilteredContext(): Record<string, unknown>;
}

export { MockContextManager, SpyTransport };
export type { SyntropyLogTestHarness };
