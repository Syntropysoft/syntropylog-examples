import { z } from 'zod';
import { EventEmitter } from 'events';
import { RedisClientType, RedisModules, RedisFunctions, RedisScripts, RedisClusterType } from 'redis';
import chalk from 'chalk';

/**
 * @file src/logger/levels.ts
 * @description Defines the available log levels, their names, and their severity weights.
 */
/**
 * @description A mapping of log level names to their severity weights.
 * Higher numbers indicate higher severity.
 */
declare const LOG_LEVEL_WEIGHTS: {
    readonly fatal: 60;
    readonly error: 50;
    readonly warn: 40;
    readonly info: 30;
    readonly debug: 20;
    readonly trace: 10;
    readonly silent: 0;
};
/**
 * @description The type representing a valid log level name.
 */
type LogLevel$1 = keyof typeof LOG_LEVEL_WEIGHTS;

/**
 * Represents any value that can be safely serialized to JSON.
 * This is a recursive type used to ensure type safety for log metadata.
 */
type JsonValue = string | number | boolean | null | {
    [key: string]: JsonValue;
} | JsonValue[];

type LogLevel = 'fatal' | 'error' | 'warn' | 'info' | 'debug' | 'trace' | 'silent';
type LogEntry = {
    /** The severity level of the log. */
    level: LogLevel;
    /** The main log message, formatted from the arguments. */
    message: string;
    /** The ISO 8601 timestamp of when the log was created. */
    timestamp: string;
    /** Any other properties are treated as structured metadata. */
    [key: string]: any;
};
type LoggerOptions = {
    level?: LogLevel;
    serviceName?: string;
    transports?: Transport[];
    bindings?: Record<string, any>;
};

/**
 * @interface MaskingEngineOptions
 * @description Options for configuring the MaskingEngine.
 */
interface MaskingEngineOptions {
    /** Un array de nombres de campos sensibles. */
    fields?: (string | RegExp)[];
    /** El carácter de máscara. */
    maskChar?: string;
    /** Profundidad máxima de búsqueda. Default: 3 */
    maxDepth?: number;
    /** El estilo de enmascaramiento ('fixed' o 'preserve-length'). */
    style?: 'fixed' | 'preserve-length';
}
/**
 * @class MaskingEngine
 * A central engine responsible for applying masking rules to log metadata.
 * It recursively scans objects and masks data based on key names, and can also
 * sanitize sensitive values from URL paths. Its design is "secure-by-default,"
 * allowing for runtime configuration updates that can only add (not remove) masking rules.
 */
declare class MaskingEngine {
    /** @private A dynamic array of sensitive field names or RegExps. */
    private fieldConfigs;
    /** @private The character(s) to use for masking. */
    private readonly maskChar;
    /** @private The maximum recursion depth for masking nested objects. */
    private readonly maxDepth;
    /** @private The masking style to apply. */
    private readonly style;
    /** @private Secure regex tester with timeout. */
    private readonly regexTest;
    constructor(options?: MaskingEngineOptions);
    /**
     * Adds new sensitive fields to the masking configuration at runtime.
     * This method is "additive only" to prevent security degradation. Once a field
     * is added to the mask list, it cannot be removed during the application's lifecycle.
     *
     * @param {(string | RegExp)[]} fields - An array of new field names or RegExps to add.
     *        Duplicates are silently ignored.
     */
    addFields(fields: (string | RegExp)[]): void;
    /**
     * Processes a metadata object and applies the configured masking rules.
     * @param {Record<string, any>} meta - The metadata object to process.
     * @returns {Record<string, any>} A new object with the masked data.
     */
    process(meta: Record<string, unknown>): Promise<Record<string, unknown>>;
    /**
     * @private
     * Recursively traverses an object or array to mask data.
     * It applies two types of masking:
     * 1. **Key-based masking**: If an object key matches a rule in `fieldConfigs`, its value is masked.
     * 2. **Path-based masking**: If a string value looks like a path/URL, it's sanitized.
     *
     * @param {any} data - The data to process (can be an object, array, or primitive).
     * @param {string} currentPath - The dot-notation path of the current key.
     * @param {number} depth - The current recursion depth to prevent infinite loops.
     * @returns {any} The processed data with masking applied.
     */
    private maskRecursively;
    /**
     * @private
     * Checks if a given object key path is sensitive based on the configured rules.
     * @param {string} path - The dot-notation path of the key (e.g., "user.password").
     * @returns {Promise<boolean>} - True if the path should be masked.
     */
    private isSensitive;
    /**
     * @private
     * Sanitizes a string that may represent a URL path.
     * If a segment of the path matches a sensitive field name (case-insensitively),
     * the following path segment is completely replaced with the mask character.
     *
     * @example
     * // with `fields: ['password']`
     * sanitizeUrlPath("/api/v1/password/s3cr3t-v4lu3")
     * // returns: "/api/v1/password/*****"
     *
     * @param {string} str - The string to sanitize.
     * @returns {string} The sanitized string, or the original if no sensitive keywords were found.
     */
    private sanitizeUrlPath;
    /**
     * @private
     * Generates the appropriate mask string based on the configured style.
     * @param {any} originalValue - The original value being masked. Its length is used for 'preserve-length' style.
     * @returns {string} The generated mask string.
     */
    private getMask;
}

/**
 * @file src/sanitization/SanitizationEngine.ts
 * @description Final security layer that sanitizes log entries before they are written by a transport.
 */

/**
 * @class SanitizationEngine
 * A security engine that makes log entries safe for printing by stripping
 * potentially malicious control characters, such as ANSI escape codes.
 * This prevents log injection attacks that could exploit terminal vulnerabilities.
 */
declare class SanitizationEngine {
    private readonly maskingEngine?;
    /** @private This regex matches ANSI escape codes used for colors, cursor movement, etc. */
    private readonly ansiRegex;
    /**
     * @constructor
     * The engine is currently not configurable, but the constructor is in place for future enhancements.
     */
    constructor(maskingEngine?: MaskingEngine);
    /**
     * Processes a log metadata object, sanitizing all its string values.
     * @param {Record<string, any>} meta - The metadata object to sanitize.
     * @returns {Record<string, any>} A new, sanitized metadata object.
     */
    process(meta: Record<string, any>): Record<string, any>;
    /**
     * @private
     * Recursively traverses an object or array to sanitize all string values.
     * @param {any} data - The data to process.
     * @returns {any} The sanitized data.
     */
    private sanitizeRecursively;
}

/**
 * @file src/logger/transports/formatters/LogFormatter.ts
 * @description Defines the public contract for log entry formatters.
 */

/**
 * @interface LogFormatter
 * @description Defines the interface for a log formatter.
 * A formatter is responsible for transforming a standard LogEntry object
 * into a specific structure required by a target destination (e.g., Datadog JSON, Elastic Common Schema).
 */
interface LogFormatter {
    /**
     * Transforms a LogEntry object into a new object with the desired format.
     * @param {LogEntry} entry - The standard log entry object to be transformed.
     * @returns {Record<string, any>} A new object representing the log in the target format.
     */
    format(entry: LogEntry): Record<string, any>;
}

/**
 * @file src/logger/transports/Transport.ts
 * @description Defines the abstract base class for all log transports.
 */

/**
 * @interface TransportOptions
 * @description Defines the options for configuring a transport.
 */
interface TransportOptions {
    /**
     * The minimum log level this transport will handle.
     * If not specified, the transport will handle all levels defined by the logger.
     */
    level?: LogLevel$1;
    /**
     * An optional formatter to transform the log entry before output.
     */
    formatter?: LogFormatter;
    /**
     * An optional, pre-configured sanitization engine.
     * If provided, the transport will use it to sanitize logs. This is typically
     * used by production-safe transports like `ConsoleTransport`.
     */
    sanitizationEngine?: SanitizationEngine;
    /**
     * An optional name for the transport, useful for debugging.
     */
    name?: string;
}
/**
 * @class Transport
 * @description The abstract base class for all log transports. A transport is
 * responsible for the final output of a log entry, whether it's to the console,
 * a file, or a remote service.
 */
declare abstract class Transport {
    level: LogLevel$1;
    name: string;
    /** The formatter instance to transform log entries. */
    protected readonly formatter?: LogFormatter;
    /** The engine used to sanitize sensitive data. */
    protected readonly sanitizationEngine?: SanitizationEngine;
    /**
     * @constructor
     * @param {TransportOptions} [options] - The configuration options for this transport.
     */
    constructor(options?: TransportOptions);
    /**
     * Determines if the transport should process a log entry based on its log level.
     * @param level - The level of the log entry to check.
     * @returns {boolean} - True if the transport is enabled for this level, false otherwise.
     */
    isLevelEnabled(level: LogLevel$1): boolean;
    /**
     * The core method that all concrete transports must implement. This method
     * handles the actual sending/writing of the log entry.
     * @param {LogEntry} entry - The final, processed log entry to be outputted.
     * @returns {Promise<void>}
     */
    abstract log(entry: LogEntry): Promise<void>;
    /**
     * A method to ensure all buffered logs are written before the application exits.
     * Subclasses should override this if they perform I/O buffering.
     * @returns {Promise<void>} A promise that resolves when flushing is complete.
     */
    flush(): Promise<void>;
}

/**
 * @file src/http/adapters/adapter.types.ts
 * @description Defines the "Universal HTTP Contract" for any HTTP client that
 * wants to be instrumented by SyntropyLog. These generic interfaces are key
 * to decoupling the framework from specific implementations like axios or got.
 */
/**
 * @interface AdapterHttpRequest
 * @description Represents a generic, normalized HTTP request that the framework
 * can understand. The adapter is responsible for converting this to the
 * specific format of the underlying library (e.g., AxiosRequestConfig).
 */
interface AdapterHttpRequest {
    /** The full URL for the request. */
    url: string;
    /** The HTTP method. */
    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
    /** A record of request headers. */
    headers: Record<string, string | number | string[]>;
    /** The request body, if any. */
    body?: unknown;
    /** A record of URL query parameters. */
    queryParams?: Record<string, any>;
}
/**
 * @interface AdapterHttpResponse
 * @description Represents a generic, normalized HTTP response. The adapter
 * will convert the library-specific response into this format.
 * @template T The expected type of the response body data.
 */
interface AdapterHttpResponse<T = any> {
    /** The HTTP status code of the response. */
    statusCode: number;
    /** The response body data. */
    data: T;
    /** A record of response headers. */
    headers: Record<string, string | number | string[]>;
}
/**
 * @interface IHttpClientAdapter
 * @description The interface that every HTTP Client Adapter must implement.
 * This is the "plug" where users will connect their clients.
 */
interface IHttpClientAdapter {
    /**
     * The core method that the SyntropyLog instrumenter needs. It executes an
     * HTTP request and returns a normalized response, or throws a normalized error.
     * @template T The expected type of the response body data.
     * @param {AdapterHttpRequest} request The generic HTTP request to execute.
     * @returns {Promise<AdapterHttpResponse<T>>} A promise that resolves with the normalized response.
     */
    request<T>(request: AdapterHttpRequest): Promise<AdapterHttpResponse<T>>;
}

/**
 * @file src/brokers/adapter.types.ts
 * @description Defines the "Universal Broker Contract" for any messaging client
 * that wants to be instrumented by SyntropyLog. These generic interfaces
 * are key to decoupling the framework from specific implementations like
 * RabbitMQ or Kafka.
 */
/**
 * @interface BrokerMessage
 * @description Represents a standard message format that the framework understands.
 * The adapter is responsible for converting the broker-specific message
 * format to this structure, and vice-versa.
 */
interface BrokerMessage {
    /**
     * The actual content of the message. Using `Buffer` is the most flexible
     * approach as it supports any type of serialization (JSON, Avro, Protobuf, etc.).
     */
    payload: Buffer;
    /**
     * Key-value metadata attached to the message.
     * This is where SyntropyLog will inject tracing headers like `correlation-id`.
     */
    headers?: Record<string, string | Buffer>;
}
/**
 * @interface MessageLifecycleControls
 * @description Defines the controls for handling a received message's lifecycle.
 * An instance of this is passed to the user's message handler, allowing them
 * to confirm or reject the message.
 */
interface MessageLifecycleControls {
    /**
     * Acknowledges that the message has been successfully processed.
     * This typically removes the message from the queue.
     * @returns {Promise<void>}
     */
    ack: () => Promise<void>;
    /**
     * Negatively acknowledges the message, indicating a processing failure.
     * @param {boolean} [requeue=false] - If true, asks the broker to re-queue the message
     * for another attempt. If false (or omitted), the broker might move it to a dead-letter queue
     * or discard it, depending on its configuration.
     * @returns {Promise<void>}
     */
    nack: (requeue?: boolean) => Promise<void>;
}
/**
 * @type MessageHandler
 * @description The signature for the user-provided function that will process incoming messages.
 * @param {BrokerMessage} message - The received message in the framework's standard format.
 * @param {MessageLifecycleControls} controls - The functions to manage the message's lifecycle (ack/nack).
 * @returns {Promise<void>}
 */
type MessageHandler = (message: BrokerMessage, controls: MessageLifecycleControls) => Promise<void>;
/**
 * @interface IBrokerAdapter
 * @description The interface that every Broker Client Adapter must implement.
 * This is the "plug" where users will connect their specific messaging clients
 * (e.g., `amqplib`, `kafkajs`).
 */
interface IBrokerAdapter {
    /**
     * Establishes a connection to the message broker.
     * @returns {Promise<void>}
     */
    connect(): Promise<void>;
    /**
     * Gracefully disconnects from the broker.
     */
    /**
     * Gracefully disconnects from the message broker.
     * @returns {Promise<void>}
     */
    disconnect(): Promise<void>;
    /**
     * Publishes a message to a specific topic or routing key.
     * @param {string} topic - The destination for the message (e.g., a topic name, queue name, or routing key).
     * @param {BrokerMessage} message - The message to be sent, in the framework's standard format.
     * @returns {Promise<void>}
     */
    publish(topic: string, message: BrokerMessage): Promise<void>;
    /**
     * Subscribes to a topic or queue to receive messages.
     * @param {string} topic - The source of messages to listen to (e.g., a topic name or queue name).
     * @param {MessageHandler} handler - The user's function that will be called for each incoming message.
     * @returns {Promise<void>}
     */
    subscribe(topic: string, handler: MessageHandler): Promise<void>;
}

/**
 * FILE: src/config.schema.ts
 * DESCRIPTION: Defines the Zod validation schemas for the entire library's configuration.
 * These schemas are the single source of truth for the configuration's structure and types.
 */

/**
 * @description Schema for a single Redis instance, using a discriminated union for different connection modes.
 */
declare const redisInstanceConfigSchema: z.ZodDiscriminatedUnion<"mode", [z.ZodObject<{
    mode: z.ZodLiteral<"single">;
    instanceName: z.ZodString;
    url: z.ZodString;
    retryOptions: z.ZodOptional<z.ZodObject<{
        maxRetries: z.ZodOptional<z.ZodNumber>;
        retryDelay: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        maxRetries?: number | undefined;
        retryDelay?: number | undefined;
    }, {
        maxRetries?: number | undefined;
        retryDelay?: number | undefined;
    }>>;
    logging: z.ZodOptional<z.ZodObject<{
        /** Level for successful commands. @default 'debug' */
        onSuccess: z.ZodDefault<z.ZodEnum<["trace", "debug", "info"]>>;
        /** Level for failed commands. @default 'error' */
        onError: z.ZodDefault<z.ZodEnum<["warn", "error", "fatal"]>>;
        /** Whether to log command parameters. @default true */
        logCommandValues: z.ZodDefault<z.ZodBoolean>;
        /** Whether to log the return value of commands. @default false */
        logReturnValue: z.ZodDefault<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        onSuccess: "info" | "debug" | "trace";
        onError: "fatal" | "error" | "warn";
        logCommandValues: boolean;
        logReturnValue: boolean;
    }, {
        onSuccess?: "info" | "debug" | "trace" | undefined;
        onError?: "fatal" | "error" | "warn" | undefined;
        logCommandValues?: boolean | undefined;
        logReturnValue?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    mode: "single";
    instanceName: string;
    url: string;
    retryOptions?: {
        maxRetries?: number | undefined;
        retryDelay?: number | undefined;
    } | undefined;
    logging?: {
        onSuccess: "info" | "debug" | "trace";
        onError: "fatal" | "error" | "warn";
        logCommandValues: boolean;
        logReturnValue: boolean;
    } | undefined;
}, {
    mode: "single";
    instanceName: string;
    url: string;
    retryOptions?: {
        maxRetries?: number | undefined;
        retryDelay?: number | undefined;
    } | undefined;
    logging?: {
        onSuccess?: "info" | "debug" | "trace" | undefined;
        onError?: "fatal" | "error" | "warn" | undefined;
        logCommandValues?: boolean | undefined;
        logReturnValue?: boolean | undefined;
    } | undefined;
}>, z.ZodObject<{
    mode: z.ZodLiteral<"sentinel">;
    instanceName: z.ZodString;
    name: z.ZodString;
    sentinels: z.ZodArray<z.ZodObject<{
        host: z.ZodString;
        port: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        host: string;
        port: number;
    }, {
        host: string;
        port: number;
    }>, "many">;
    sentinelPassword: z.ZodOptional<z.ZodString>;
    retryOptions: z.ZodOptional<z.ZodObject<{
        maxRetries: z.ZodOptional<z.ZodNumber>;
        retryDelay: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        maxRetries?: number | undefined;
        retryDelay?: number | undefined;
    }, {
        maxRetries?: number | undefined;
        retryDelay?: number | undefined;
    }>>;
    logging: z.ZodOptional<z.ZodObject<{
        onSuccess: z.ZodDefault<z.ZodEnum<["trace", "debug", "info"]>>;
        onError: z.ZodDefault<z.ZodEnum<["warn", "error", "fatal"]>>;
        logCommandValues: z.ZodDefault<z.ZodBoolean>;
        logReturnValue: z.ZodDefault<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        onSuccess: "info" | "debug" | "trace";
        onError: "fatal" | "error" | "warn";
        logCommandValues: boolean;
        logReturnValue: boolean;
    }, {
        onSuccess?: "info" | "debug" | "trace" | undefined;
        onError?: "fatal" | "error" | "warn" | undefined;
        logCommandValues?: boolean | undefined;
        logReturnValue?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    name: string;
    mode: "sentinel";
    instanceName: string;
    sentinels: {
        host: string;
        port: number;
    }[];
    retryOptions?: {
        maxRetries?: number | undefined;
        retryDelay?: number | undefined;
    } | undefined;
    logging?: {
        onSuccess: "info" | "debug" | "trace";
        onError: "fatal" | "error" | "warn";
        logCommandValues: boolean;
        logReturnValue: boolean;
    } | undefined;
    sentinelPassword?: string | undefined;
}, {
    name: string;
    mode: "sentinel";
    instanceName: string;
    sentinels: {
        host: string;
        port: number;
    }[];
    retryOptions?: {
        maxRetries?: number | undefined;
        retryDelay?: number | undefined;
    } | undefined;
    logging?: {
        onSuccess?: "info" | "debug" | "trace" | undefined;
        onError?: "fatal" | "error" | "warn" | undefined;
        logCommandValues?: boolean | undefined;
        logReturnValue?: boolean | undefined;
    } | undefined;
    sentinelPassword?: string | undefined;
}>, z.ZodObject<{
    mode: z.ZodLiteral<"cluster">;
    instanceName: z.ZodString;
    rootNodes: z.ZodArray<z.ZodObject<{
        host: z.ZodString;
        port: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        host: string;
        port: number;
    }, {
        host: string;
        port: number;
    }>, "many">;
    logging: z.ZodOptional<z.ZodObject<{
        /** Level for successful commands. @default 'debug' */
        onSuccess: z.ZodDefault<z.ZodEnum<["trace", "debug", "info"]>>;
        /** Level for failed commands. @default 'error' */
        onError: z.ZodDefault<z.ZodEnum<["warn", "error", "fatal"]>>;
        /** Whether to log command parameters. @default true */
        logCommandValues: z.ZodDefault<z.ZodBoolean>;
        /** Whether to log the return value of commands. @default false */
        logReturnValue: z.ZodDefault<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        onSuccess: "info" | "debug" | "trace";
        onError: "fatal" | "error" | "warn";
        logCommandValues: boolean;
        logReturnValue: boolean;
    }, {
        onSuccess?: "info" | "debug" | "trace" | undefined;
        onError?: "fatal" | "error" | "warn" | undefined;
        logCommandValues?: boolean | undefined;
        logReturnValue?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    mode: "cluster";
    instanceName: string;
    rootNodes: {
        host: string;
        port: number;
    }[];
    logging?: {
        onSuccess: "info" | "debug" | "trace";
        onError: "fatal" | "error" | "warn";
        logCommandValues: boolean;
        logReturnValue: boolean;
    } | undefined;
}, {
    mode: "cluster";
    instanceName: string;
    rootNodes: {
        host: string;
        port: number;
    }[];
    logging?: {
        onSuccess?: "info" | "debug" | "trace" | undefined;
        onError?: "fatal" | "error" | "warn" | undefined;
        logCommandValues?: boolean | undefined;
        logReturnValue?: boolean | undefined;
    } | undefined;
}>]>;
/**
 * @description Schema for a single HTTP client instance.
 */
declare const httpInstanceConfigSchema: z.ZodObject<{
    instanceName: z.ZodString;
    adapter: z.ZodType<IHttpClientAdapter, z.ZodTypeDef, IHttpClientAdapter>;
    isDefault: z.ZodOptional<z.ZodBoolean>;
    propagate: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    propagateFullContext: z.ZodOptional<z.ZodBoolean>;
    logging: z.ZodOptional<z.ZodObject<{
        onSuccess: z.ZodOptional<z.ZodDefault<z.ZodEnum<["trace", "debug", "info"]>>>;
        onError: z.ZodOptional<z.ZodDefault<z.ZodEnum<["warn", "error", "fatal"]>>>;
        logSuccessBody: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
        logSuccessHeaders: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
        onRequest: z.ZodOptional<z.ZodDefault<z.ZodEnum<["trace", "debug", "info"]>>>;
        logRequestBody: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
        logRequestHeaders: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
    }, "strip", z.ZodTypeAny, {
        onSuccess?: "info" | "debug" | "trace" | undefined;
        onError?: "fatal" | "error" | "warn" | undefined;
        logSuccessBody?: boolean | undefined;
        logSuccessHeaders?: boolean | undefined;
        onRequest?: "info" | "debug" | "trace" | undefined;
        logRequestBody?: boolean | undefined;
        logRequestHeaders?: boolean | undefined;
    }, {
        onSuccess?: "info" | "debug" | "trace" | undefined;
        onError?: "fatal" | "error" | "warn" | undefined;
        logSuccessBody?: boolean | undefined;
        logSuccessHeaders?: boolean | undefined;
        onRequest?: "info" | "debug" | "trace" | undefined;
        logRequestBody?: boolean | undefined;
        logRequestHeaders?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    instanceName: string;
    adapter: IHttpClientAdapter;
    logging?: {
        onSuccess?: "info" | "debug" | "trace" | undefined;
        onError?: "fatal" | "error" | "warn" | undefined;
        logSuccessBody?: boolean | undefined;
        logSuccessHeaders?: boolean | undefined;
        onRequest?: "info" | "debug" | "trace" | undefined;
        logRequestBody?: boolean | undefined;
        logRequestHeaders?: boolean | undefined;
    } | undefined;
    isDefault?: boolean | undefined;
    propagate?: string[] | undefined;
    propagateFullContext?: boolean | undefined;
}, {
    instanceName: string;
    adapter: IHttpClientAdapter;
    logging?: {
        onSuccess?: "info" | "debug" | "trace" | undefined;
        onError?: "fatal" | "error" | "warn" | undefined;
        logSuccessBody?: boolean | undefined;
        logSuccessHeaders?: boolean | undefined;
        onRequest?: "info" | "debug" | "trace" | undefined;
        logRequestBody?: boolean | undefined;
        logRequestHeaders?: boolean | undefined;
    } | undefined;
    isDefault?: boolean | undefined;
    propagate?: string[] | undefined;
    propagateFullContext?: boolean | undefined;
}>;
/**
 * @description Schema for a single message broker client instance.
 * It validates that a valid `IBrokerAdapter` is provided.
 * @private
 */
declare const brokerInstanceConfigSchema: z.ZodObject<{
    instanceName: z.ZodString;
    adapter: z.ZodType<IBrokerAdapter, z.ZodTypeDef, IBrokerAdapter>;
    /**
     * An array of context keys to propagate as message headers/properties.
     * To propagate all keys, provide an array with a single wildcard: `['*']`.
     * If not provided, only `correlationId` and `transactionId` are propagated by default.
     */
    propagate: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    /**
     * @deprecated Use `propagate` instead.
     * If true, propagates the entire asynchronous context map as headers.
     * If false (default), only propagates `correlationId` and `transactionId`.
     */
    propagateFullContext: z.ZodOptional<z.ZodBoolean>;
    isDefault: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    instanceName: string;
    adapter: IBrokerAdapter;
    isDefault?: boolean | undefined;
    propagate?: string[] | undefined;
    propagateFullContext?: boolean | undefined;
}, {
    instanceName: string;
    adapter: IBrokerAdapter;
    isDefault?: boolean | undefined;
    propagate?: string[] | undefined;
    propagateFullContext?: boolean | undefined;
}>;
/**
 * @description The main schema for the entire SyntropyLog configuration.
 * This is the single source of truth for validating the user's configuration object.
 */
declare const syntropyLogConfigSchema: z.ZodObject<{
    /** Logger-specific configuration. */
    logger: z.ZodOptional<z.ZodObject<{
        name: z.ZodOptional<z.ZodString>;
        level: z.ZodOptional<z.ZodEnum<["fatal", "error", "warn", "info", "debug", "trace", "silent"]>>;
        serviceName: z.ZodOptional<z.ZodString>;
        /**
         * An array of transport instances to be used by the logger.
         */
        transports: z.ZodOptional<z.ZodArray<z.ZodType<Transport, z.ZodTypeDef, Transport>, "many">>;
        /**
         * A dictionary of custom serializer functions. The key is the field
         * to look for in the log object, and the value is the function that transforms it.
         */
        serializers: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodFunction<z.ZodTuple<[z.ZodAny], z.ZodUnknown>, z.ZodString>>>;
        /**
         * The maximum time in milliseconds a custom serializer can run before being timed out.
         * @default 50
         */
        serializerTimeoutMs: z.ZodDefault<z.ZodNumber>;
        /** Configuration for pretty printing logs in development. */
        prettyPrint: z.ZodOptional<z.ZodObject<{
            enabled: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
        }, "strip", z.ZodTypeAny, {
            enabled: boolean;
        }, {
            enabled?: boolean | undefined;
        }>>;
    }, "strip", z.ZodTypeAny, {
        serializerTimeoutMs: number;
        level?: "fatal" | "error" | "warn" | "info" | "debug" | "trace" | "silent" | undefined;
        name?: string | undefined;
        serviceName?: string | undefined;
        transports?: Transport[] | undefined;
        serializers?: Record<string, (args_0: any, ...args: unknown[]) => string> | undefined;
        prettyPrint?: {
            enabled: boolean;
        } | undefined;
    }, {
        level?: "fatal" | "error" | "warn" | "info" | "debug" | "trace" | "silent" | undefined;
        name?: string | undefined;
        serviceName?: string | undefined;
        transports?: Transport[] | undefined;
        serializers?: Record<string, (args_0: any, ...args: unknown[]) => string> | undefined;
        serializerTimeoutMs?: number | undefined;
        prettyPrint?: {
            enabled?: boolean | undefined;
        } | undefined;
    }>>;
    /** Declarative matrix to control context data in logs. */
    loggingMatrix: z.ZodOptional<z.ZodObject<{
        /** An array of context keys to include in logs by default. Can be overridden by level-specific rules. */
        default: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        /** An array of context keys to include for 'trace' level logs. Use `['*']` to include all context properties. */
        trace: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        /** An array of context keys to include for 'debug' level logs. Use `['*']` to include all context properties. */
        debug: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        /** An array of context keys to include for 'info' level logs. Use `['*']` to include all context properties. */
        info: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        /** An array of context keys to include for 'warn' level logs. Use `['*']` to include all context properties. */
        warn: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        /** An array of context keys to include for 'error' level logs. Use `['*']` to include all context properties. */
        error: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        /** An array of context keys to include for 'fatal' level logs. Use `['*']` to include all context properties. */
        fatal: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, "strip", z.ZodTypeAny, {
        fatal?: string[] | undefined;
        error?: string[] | undefined;
        warn?: string[] | undefined;
        info?: string[] | undefined;
        debug?: string[] | undefined;
        trace?: string[] | undefined;
        default?: string[] | undefined;
    }, {
        fatal?: string[] | undefined;
        error?: string[] | undefined;
        warn?: string[] | undefined;
        info?: string[] | undefined;
        debug?: string[] | undefined;
        trace?: string[] | undefined;
        default?: string[] | undefined;
    }>>;
    /** Redis client configuration. */
    redis: z.ZodOptional<z.ZodObject<{
        /** An array of Redis instance configurations. */
        instances: z.ZodArray<z.ZodDiscriminatedUnion<"mode", [z.ZodObject<{
            mode: z.ZodLiteral<"single">;
            instanceName: z.ZodString;
            url: z.ZodString;
            retryOptions: z.ZodOptional<z.ZodObject<{
                maxRetries: z.ZodOptional<z.ZodNumber>;
                retryDelay: z.ZodOptional<z.ZodNumber>;
            }, "strip", z.ZodTypeAny, {
                maxRetries?: number | undefined;
                retryDelay?: number | undefined;
            }, {
                maxRetries?: number | undefined;
                retryDelay?: number | undefined;
            }>>;
            logging: z.ZodOptional<z.ZodObject<{
                /** Level for successful commands. @default 'debug' */
                onSuccess: z.ZodDefault<z.ZodEnum<["trace", "debug", "info"]>>;
                /** Level for failed commands. @default 'error' */
                onError: z.ZodDefault<z.ZodEnum<["warn", "error", "fatal"]>>;
                /** Whether to log command parameters. @default true */
                logCommandValues: z.ZodDefault<z.ZodBoolean>;
                /** Whether to log the return value of commands. @default false */
                logReturnValue: z.ZodDefault<z.ZodBoolean>;
            }, "strip", z.ZodTypeAny, {
                onSuccess: "info" | "debug" | "trace";
                onError: "fatal" | "error" | "warn";
                logCommandValues: boolean;
                logReturnValue: boolean;
            }, {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logCommandValues?: boolean | undefined;
                logReturnValue?: boolean | undefined;
            }>>;
        }, "strip", z.ZodTypeAny, {
            mode: "single";
            instanceName: string;
            url: string;
            retryOptions?: {
                maxRetries?: number | undefined;
                retryDelay?: number | undefined;
            } | undefined;
            logging?: {
                onSuccess: "info" | "debug" | "trace";
                onError: "fatal" | "error" | "warn";
                logCommandValues: boolean;
                logReturnValue: boolean;
            } | undefined;
        }, {
            mode: "single";
            instanceName: string;
            url: string;
            retryOptions?: {
                maxRetries?: number | undefined;
                retryDelay?: number | undefined;
            } | undefined;
            logging?: {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logCommandValues?: boolean | undefined;
                logReturnValue?: boolean | undefined;
            } | undefined;
        }>, z.ZodObject<{
            mode: z.ZodLiteral<"sentinel">;
            instanceName: z.ZodString;
            name: z.ZodString;
            sentinels: z.ZodArray<z.ZodObject<{
                host: z.ZodString;
                port: z.ZodNumber;
            }, "strip", z.ZodTypeAny, {
                host: string;
                port: number;
            }, {
                host: string;
                port: number;
            }>, "many">;
            sentinelPassword: z.ZodOptional<z.ZodString>;
            retryOptions: z.ZodOptional<z.ZodObject<{
                maxRetries: z.ZodOptional<z.ZodNumber>;
                retryDelay: z.ZodOptional<z.ZodNumber>;
            }, "strip", z.ZodTypeAny, {
                maxRetries?: number | undefined;
                retryDelay?: number | undefined;
            }, {
                maxRetries?: number | undefined;
                retryDelay?: number | undefined;
            }>>;
            logging: z.ZodOptional<z.ZodObject<{
                onSuccess: z.ZodDefault<z.ZodEnum<["trace", "debug", "info"]>>;
                onError: z.ZodDefault<z.ZodEnum<["warn", "error", "fatal"]>>;
                logCommandValues: z.ZodDefault<z.ZodBoolean>;
                logReturnValue: z.ZodDefault<z.ZodBoolean>;
            }, "strip", z.ZodTypeAny, {
                onSuccess: "info" | "debug" | "trace";
                onError: "fatal" | "error" | "warn";
                logCommandValues: boolean;
                logReturnValue: boolean;
            }, {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logCommandValues?: boolean | undefined;
                logReturnValue?: boolean | undefined;
            }>>;
        }, "strip", z.ZodTypeAny, {
            name: string;
            mode: "sentinel";
            instanceName: string;
            sentinels: {
                host: string;
                port: number;
            }[];
            retryOptions?: {
                maxRetries?: number | undefined;
                retryDelay?: number | undefined;
            } | undefined;
            logging?: {
                onSuccess: "info" | "debug" | "trace";
                onError: "fatal" | "error" | "warn";
                logCommandValues: boolean;
                logReturnValue: boolean;
            } | undefined;
            sentinelPassword?: string | undefined;
        }, {
            name: string;
            mode: "sentinel";
            instanceName: string;
            sentinels: {
                host: string;
                port: number;
            }[];
            retryOptions?: {
                maxRetries?: number | undefined;
                retryDelay?: number | undefined;
            } | undefined;
            logging?: {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logCommandValues?: boolean | undefined;
                logReturnValue?: boolean | undefined;
            } | undefined;
            sentinelPassword?: string | undefined;
        }>, z.ZodObject<{
            mode: z.ZodLiteral<"cluster">;
            instanceName: z.ZodString;
            rootNodes: z.ZodArray<z.ZodObject<{
                host: z.ZodString;
                port: z.ZodNumber;
            }, "strip", z.ZodTypeAny, {
                host: string;
                port: number;
            }, {
                host: string;
                port: number;
            }>, "many">;
            logging: z.ZodOptional<z.ZodObject<{
                /** Level for successful commands. @default 'debug' */
                onSuccess: z.ZodDefault<z.ZodEnum<["trace", "debug", "info"]>>;
                /** Level for failed commands. @default 'error' */
                onError: z.ZodDefault<z.ZodEnum<["warn", "error", "fatal"]>>;
                /** Whether to log command parameters. @default true */
                logCommandValues: z.ZodDefault<z.ZodBoolean>;
                /** Whether to log the return value of commands. @default false */
                logReturnValue: z.ZodDefault<z.ZodBoolean>;
            }, "strip", z.ZodTypeAny, {
                onSuccess: "info" | "debug" | "trace";
                onError: "fatal" | "error" | "warn";
                logCommandValues: boolean;
                logReturnValue: boolean;
            }, {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logCommandValues?: boolean | undefined;
                logReturnValue?: boolean | undefined;
            }>>;
        }, "strip", z.ZodTypeAny, {
            mode: "cluster";
            instanceName: string;
            rootNodes: {
                host: string;
                port: number;
            }[];
            logging?: {
                onSuccess: "info" | "debug" | "trace";
                onError: "fatal" | "error" | "warn";
                logCommandValues: boolean;
                logReturnValue: boolean;
            } | undefined;
        }, {
            mode: "cluster";
            instanceName: string;
            rootNodes: {
                host: string;
                port: number;
            }[];
            logging?: {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logCommandValues?: boolean | undefined;
                logReturnValue?: boolean | undefined;
            } | undefined;
        }>]>, "many">;
        /** The name of the default Redis instance to use when no name is provided to `getInstance()`. */
        default: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        instances: ({
            mode: "single";
            instanceName: string;
            url: string;
            retryOptions?: {
                maxRetries?: number | undefined;
                retryDelay?: number | undefined;
            } | undefined;
            logging?: {
                onSuccess: "info" | "debug" | "trace";
                onError: "fatal" | "error" | "warn";
                logCommandValues: boolean;
                logReturnValue: boolean;
            } | undefined;
        } | {
            name: string;
            mode: "sentinel";
            instanceName: string;
            sentinels: {
                host: string;
                port: number;
            }[];
            retryOptions?: {
                maxRetries?: number | undefined;
                retryDelay?: number | undefined;
            } | undefined;
            logging?: {
                onSuccess: "info" | "debug" | "trace";
                onError: "fatal" | "error" | "warn";
                logCommandValues: boolean;
                logReturnValue: boolean;
            } | undefined;
            sentinelPassword?: string | undefined;
        } | {
            mode: "cluster";
            instanceName: string;
            rootNodes: {
                host: string;
                port: number;
            }[];
            logging?: {
                onSuccess: "info" | "debug" | "trace";
                onError: "fatal" | "error" | "warn";
                logCommandValues: boolean;
                logReturnValue: boolean;
            } | undefined;
        })[];
        default?: string | undefined;
    }, {
        instances: ({
            mode: "single";
            instanceName: string;
            url: string;
            retryOptions?: {
                maxRetries?: number | undefined;
                retryDelay?: number | undefined;
            } | undefined;
            logging?: {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logCommandValues?: boolean | undefined;
                logReturnValue?: boolean | undefined;
            } | undefined;
        } | {
            name: string;
            mode: "sentinel";
            instanceName: string;
            sentinels: {
                host: string;
                port: number;
            }[];
            retryOptions?: {
                maxRetries?: number | undefined;
                retryDelay?: number | undefined;
            } | undefined;
            logging?: {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logCommandValues?: boolean | undefined;
                logReturnValue?: boolean | undefined;
            } | undefined;
            sentinelPassword?: string | undefined;
        } | {
            mode: "cluster";
            instanceName: string;
            rootNodes: {
                host: string;
                port: number;
            }[];
            logging?: {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logCommandValues?: boolean | undefined;
                logReturnValue?: boolean | undefined;
            } | undefined;
        })[];
        default?: string | undefined;
    }>>;
    /** HTTP client configuration. */
    http: z.ZodOptional<z.ZodObject<{
        /** An array of HTTP client instance configurations. */
        instances: z.ZodArray<z.ZodObject<{
            instanceName: z.ZodString;
            adapter: z.ZodType<IHttpClientAdapter, z.ZodTypeDef, IHttpClientAdapter>;
            isDefault: z.ZodOptional<z.ZodBoolean>;
            propagate: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            propagateFullContext: z.ZodOptional<z.ZodBoolean>;
            logging: z.ZodOptional<z.ZodObject<{
                onSuccess: z.ZodOptional<z.ZodDefault<z.ZodEnum<["trace", "debug", "info"]>>>;
                onError: z.ZodOptional<z.ZodDefault<z.ZodEnum<["warn", "error", "fatal"]>>>;
                logSuccessBody: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
                logSuccessHeaders: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
                onRequest: z.ZodOptional<z.ZodDefault<z.ZodEnum<["trace", "debug", "info"]>>>;
                logRequestBody: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
                logRequestHeaders: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
            }, "strip", z.ZodTypeAny, {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logSuccessBody?: boolean | undefined;
                logSuccessHeaders?: boolean | undefined;
                onRequest?: "info" | "debug" | "trace" | undefined;
                logRequestBody?: boolean | undefined;
                logRequestHeaders?: boolean | undefined;
            }, {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logSuccessBody?: boolean | undefined;
                logSuccessHeaders?: boolean | undefined;
                onRequest?: "info" | "debug" | "trace" | undefined;
                logRequestBody?: boolean | undefined;
                logRequestHeaders?: boolean | undefined;
            }>>;
        }, "strip", z.ZodTypeAny, {
            instanceName: string;
            adapter: IHttpClientAdapter;
            logging?: {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logSuccessBody?: boolean | undefined;
                logSuccessHeaders?: boolean | undefined;
                onRequest?: "info" | "debug" | "trace" | undefined;
                logRequestBody?: boolean | undefined;
                logRequestHeaders?: boolean | undefined;
            } | undefined;
            isDefault?: boolean | undefined;
            propagate?: string[] | undefined;
            propagateFullContext?: boolean | undefined;
        }, {
            instanceName: string;
            adapter: IHttpClientAdapter;
            logging?: {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logSuccessBody?: boolean | undefined;
                logSuccessHeaders?: boolean | undefined;
                onRequest?: "info" | "debug" | "trace" | undefined;
                logRequestBody?: boolean | undefined;
                logRequestHeaders?: boolean | undefined;
            } | undefined;
            isDefault?: boolean | undefined;
            propagate?: string[] | undefined;
            propagateFullContext?: boolean | undefined;
        }>, "many">;
        /** The name of the default HTTP client instance to use when no name is provided to `getInstance()`. */
        default: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        instances: {
            instanceName: string;
            adapter: IHttpClientAdapter;
            logging?: {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logSuccessBody?: boolean | undefined;
                logSuccessHeaders?: boolean | undefined;
                onRequest?: "info" | "debug" | "trace" | undefined;
                logRequestBody?: boolean | undefined;
                logRequestHeaders?: boolean | undefined;
            } | undefined;
            isDefault?: boolean | undefined;
            propagate?: string[] | undefined;
            propagateFullContext?: boolean | undefined;
        }[];
        default?: string | undefined;
    }, {
        instances: {
            instanceName: string;
            adapter: IHttpClientAdapter;
            logging?: {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logSuccessBody?: boolean | undefined;
                logSuccessHeaders?: boolean | undefined;
                onRequest?: "info" | "debug" | "trace" | undefined;
                logRequestBody?: boolean | undefined;
                logRequestHeaders?: boolean | undefined;
            } | undefined;
            isDefault?: boolean | undefined;
            propagate?: string[] | undefined;
            propagateFullContext?: boolean | undefined;
        }[];
        default?: string | undefined;
    }>>;
    /** Message broker client configuration. */
    brokers: z.ZodOptional<z.ZodObject<{
        /** An array of broker client instance configurations. */
        instances: z.ZodArray<z.ZodObject<{
            instanceName: z.ZodString;
            adapter: z.ZodType<IBrokerAdapter, z.ZodTypeDef, IBrokerAdapter>;
            /**
             * An array of context keys to propagate as message headers/properties.
             * To propagate all keys, provide an array with a single wildcard: `['*']`.
             * If not provided, only `correlationId` and `transactionId` are propagated by default.
             */
            propagate: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            /**
             * @deprecated Use `propagate` instead.
             * If true, propagates the entire asynchronous context map as headers.
             * If false (default), only propagates `correlationId` and `transactionId`.
             */
            propagateFullContext: z.ZodOptional<z.ZodBoolean>;
            isDefault: z.ZodOptional<z.ZodBoolean>;
        }, "strip", z.ZodTypeAny, {
            instanceName: string;
            adapter: IBrokerAdapter;
            isDefault?: boolean | undefined;
            propagate?: string[] | undefined;
            propagateFullContext?: boolean | undefined;
        }, {
            instanceName: string;
            adapter: IBrokerAdapter;
            isDefault?: boolean | undefined;
            propagate?: string[] | undefined;
            propagateFullContext?: boolean | undefined;
        }>, "many">;
        /** The name of the default broker instance to use when no name is provided to `getInstance()`. */
        default: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        instances: {
            instanceName: string;
            adapter: IBrokerAdapter;
            isDefault?: boolean | undefined;
            propagate?: string[] | undefined;
            propagateFullContext?: boolean | undefined;
        }[];
        default?: string | undefined;
    }, {
        instances: {
            instanceName: string;
            adapter: IBrokerAdapter;
            isDefault?: boolean | undefined;
            propagate?: string[] | undefined;
            propagateFullContext?: boolean | undefined;
        }[];
        default?: string | undefined;
    }>>;
    /** Centralized data masking configuration. */
    masking: z.ZodOptional<z.ZodObject<{
        /** An array of sensitive field names or RegExp. */
        fields: z.ZodOptional<z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodType<RegExp, z.ZodTypeDef, RegExp>]>, "many">>;
        /** The character(s) to use for masking. If `style` is 'preserve-length', only the first character is used. */
        maskChar: z.ZodOptional<z.ZodString>;
        /** The maximum recursion depth for masking nested objects. Defaults to 3. */
        maxDepth: z.ZodOptional<z.ZodNumber>;
        /**
         * The masking style.
         * - `fixed`: (Default) Replaces the value with a fixed-length string ('******'). Maximum security.
         * - `preserve-length`: Replaces the value with a mask string of the same length. Leaks length metadata.
         */
        style: z.ZodOptional<z.ZodEnum<["fixed", "preserve-length"]>>;
    }, "strip", z.ZodTypeAny, {
        fields?: (string | RegExp)[] | undefined;
        maskChar?: string | undefined;
        maxDepth?: number | undefined;
        style?: "fixed" | "preserve-length" | undefined;
    }, {
        fields?: (string | RegExp)[] | undefined;
        maskChar?: string | undefined;
        maxDepth?: number | undefined;
        style?: "fixed" | "preserve-length" | undefined;
    }>>;
    /** Context propagation configuration. */
    context: z.ZodOptional<z.ZodObject<{
        /** The HTTP header name to use for the correlation ID. @default 'x-correlation-id' */
        correlationIdHeader: z.ZodOptional<z.ZodString>;
        /** The HTTP header name to use for the external transaction/trace ID. @default 'x-trace-id' */
        transactionIdHeader: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        correlationIdHeader?: string | undefined;
        transactionIdHeader?: string | undefined;
    }, {
        correlationIdHeader?: string | undefined;
        transactionIdHeader?: string | undefined;
    }>>;
    /**
     * The maximum time in milliseconds to wait for a graceful shutdown before timing out.
     * @default 5000
     */
    shutdownTimeout: z.ZodOptional<z.ZodNumber>;
    /** Configuration for the `syntropylog doctor` CLI tool. */
    doctor: z.ZodOptional<z.ZodObject<{
        /** An array of rule IDs to disable during a diagnostic run. */
        disableRules: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, "strip", z.ZodTypeAny, {
        disableRules?: string[] | undefined;
    }, {
        disableRules?: string[] | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    logger?: {
        serializerTimeoutMs: number;
        level?: "fatal" | "error" | "warn" | "info" | "debug" | "trace" | "silent" | undefined;
        name?: string | undefined;
        serviceName?: string | undefined;
        transports?: Transport[] | undefined;
        serializers?: Record<string, (args_0: any, ...args: unknown[]) => string> | undefined;
        prettyPrint?: {
            enabled: boolean;
        } | undefined;
    } | undefined;
    loggingMatrix?: {
        fatal?: string[] | undefined;
        error?: string[] | undefined;
        warn?: string[] | undefined;
        info?: string[] | undefined;
        debug?: string[] | undefined;
        trace?: string[] | undefined;
        default?: string[] | undefined;
    } | undefined;
    redis?: {
        instances: ({
            mode: "single";
            instanceName: string;
            url: string;
            retryOptions?: {
                maxRetries?: number | undefined;
                retryDelay?: number | undefined;
            } | undefined;
            logging?: {
                onSuccess: "info" | "debug" | "trace";
                onError: "fatal" | "error" | "warn";
                logCommandValues: boolean;
                logReturnValue: boolean;
            } | undefined;
        } | {
            name: string;
            mode: "sentinel";
            instanceName: string;
            sentinels: {
                host: string;
                port: number;
            }[];
            retryOptions?: {
                maxRetries?: number | undefined;
                retryDelay?: number | undefined;
            } | undefined;
            logging?: {
                onSuccess: "info" | "debug" | "trace";
                onError: "fatal" | "error" | "warn";
                logCommandValues: boolean;
                logReturnValue: boolean;
            } | undefined;
            sentinelPassword?: string | undefined;
        } | {
            mode: "cluster";
            instanceName: string;
            rootNodes: {
                host: string;
                port: number;
            }[];
            logging?: {
                onSuccess: "info" | "debug" | "trace";
                onError: "fatal" | "error" | "warn";
                logCommandValues: boolean;
                logReturnValue: boolean;
            } | undefined;
        })[];
        default?: string | undefined;
    } | undefined;
    http?: {
        instances: {
            instanceName: string;
            adapter: IHttpClientAdapter;
            logging?: {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logSuccessBody?: boolean | undefined;
                logSuccessHeaders?: boolean | undefined;
                onRequest?: "info" | "debug" | "trace" | undefined;
                logRequestBody?: boolean | undefined;
                logRequestHeaders?: boolean | undefined;
            } | undefined;
            isDefault?: boolean | undefined;
            propagate?: string[] | undefined;
            propagateFullContext?: boolean | undefined;
        }[];
        default?: string | undefined;
    } | undefined;
    brokers?: {
        instances: {
            instanceName: string;
            adapter: IBrokerAdapter;
            isDefault?: boolean | undefined;
            propagate?: string[] | undefined;
            propagateFullContext?: boolean | undefined;
        }[];
        default?: string | undefined;
    } | undefined;
    masking?: {
        fields?: (string | RegExp)[] | undefined;
        maskChar?: string | undefined;
        maxDepth?: number | undefined;
        style?: "fixed" | "preserve-length" | undefined;
    } | undefined;
    context?: {
        correlationIdHeader?: string | undefined;
        transactionIdHeader?: string | undefined;
    } | undefined;
    shutdownTimeout?: number | undefined;
    doctor?: {
        disableRules?: string[] | undefined;
    } | undefined;
}, {
    logger?: {
        level?: "fatal" | "error" | "warn" | "info" | "debug" | "trace" | "silent" | undefined;
        name?: string | undefined;
        serviceName?: string | undefined;
        transports?: Transport[] | undefined;
        serializers?: Record<string, (args_0: any, ...args: unknown[]) => string> | undefined;
        serializerTimeoutMs?: number | undefined;
        prettyPrint?: {
            enabled?: boolean | undefined;
        } | undefined;
    } | undefined;
    loggingMatrix?: {
        fatal?: string[] | undefined;
        error?: string[] | undefined;
        warn?: string[] | undefined;
        info?: string[] | undefined;
        debug?: string[] | undefined;
        trace?: string[] | undefined;
        default?: string[] | undefined;
    } | undefined;
    redis?: {
        instances: ({
            mode: "single";
            instanceName: string;
            url: string;
            retryOptions?: {
                maxRetries?: number | undefined;
                retryDelay?: number | undefined;
            } | undefined;
            logging?: {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logCommandValues?: boolean | undefined;
                logReturnValue?: boolean | undefined;
            } | undefined;
        } | {
            name: string;
            mode: "sentinel";
            instanceName: string;
            sentinels: {
                host: string;
                port: number;
            }[];
            retryOptions?: {
                maxRetries?: number | undefined;
                retryDelay?: number | undefined;
            } | undefined;
            logging?: {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logCommandValues?: boolean | undefined;
                logReturnValue?: boolean | undefined;
            } | undefined;
            sentinelPassword?: string | undefined;
        } | {
            mode: "cluster";
            instanceName: string;
            rootNodes: {
                host: string;
                port: number;
            }[];
            logging?: {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logCommandValues?: boolean | undefined;
                logReturnValue?: boolean | undefined;
            } | undefined;
        })[];
        default?: string | undefined;
    } | undefined;
    http?: {
        instances: {
            instanceName: string;
            adapter: IHttpClientAdapter;
            logging?: {
                onSuccess?: "info" | "debug" | "trace" | undefined;
                onError?: "fatal" | "error" | "warn" | undefined;
                logSuccessBody?: boolean | undefined;
                logSuccessHeaders?: boolean | undefined;
                onRequest?: "info" | "debug" | "trace" | undefined;
                logRequestBody?: boolean | undefined;
                logRequestHeaders?: boolean | undefined;
            } | undefined;
            isDefault?: boolean | undefined;
            propagate?: string[] | undefined;
            propagateFullContext?: boolean | undefined;
        }[];
        default?: string | undefined;
    } | undefined;
    brokers?: {
        instances: {
            instanceName: string;
            adapter: IBrokerAdapter;
            isDefault?: boolean | undefined;
            propagate?: string[] | undefined;
            propagateFullContext?: boolean | undefined;
        }[];
        default?: string | undefined;
    } | undefined;
    masking?: {
        fields?: (string | RegExp)[] | undefined;
        maskChar?: string | undefined;
        maxDepth?: number | undefined;
        style?: "fixed" | "preserve-length" | undefined;
    } | undefined;
    context?: {
        correlationIdHeader?: string | undefined;
        transactionIdHeader?: string | undefined;
    } | undefined;
    shutdownTimeout?: number | undefined;
    doctor?: {
        disableRules?: string[] | undefined;
    } | undefined;
}>;

/**
 * @file src/config.ts
 * @description Defines and exports the configuration types for the library.
 * These types are inferred directly from the Zod schemas defined in `config.schema.ts`,
 * ensuring that static types and runtime validation are always in sync.
 */

/**
 * @description The complete, top-level configuration type for the SyntropyLog framework.
 * This type is inferred from the main Zod schema and represents the entire valid configuration object.
 */
type SyntropyLogConfig = z.infer<typeof syntropyLogConfigSchema>;
/**
 * @description The configuration type for a single Redis instance.
 */
type RedisInstanceConfig = z.infer<typeof redisInstanceConfigSchema>;
/**
 * @description The configuration type for a single HTTP client instance.
 */
type HttpClientInstanceConfig = z.infer<typeof httpInstanceConfigSchema>;
/**
 * @description The configuration type for a single message broker client instance.
 */
type BrokerInstanceConfig = z.infer<typeof brokerInstanceConfigSchema>;

/**
 * Defines the public interface for a logger instance.
 * This ensures a consistent API for logging across the application,
 * including standard logging methods and a fluent API for contextual logging.
 */
interface ILogger {
    level: LogLevel;
    /**
     * Logs a message at the 'fatal' level. The application will likely exit.
     * @param {object} obj - An object with properties to be included in the log.
     * @param {string} [message] - The log message, with optional format placeholders.
     * @param {...any[]} args - Values to substitute into the message placeholders.
     */
    fatal(obj: object, message?: string, ...args: any[]): void;
    fatal(message: string, ...args: any[]): void;
    /**
     * Logs a message at the 'error' level.
     * @param {object} obj - An object with properties to be included in the log.
     * @param {string} [message] - The log message, with optional format placeholders.
     * @param {...any[]} args - Values to substitute into the message placeholders.
     */
    error(obj: object, message?: string, ...args: any[]): void;
    error(message: string, ...args: any[]): void;
    /**
     * Logs a message at the 'warn' level.
     * @param {object} obj - An object with properties to be included in the log.
     * @param {string} [message] - The log message, with optional format placeholders.
     * @param {...any[]} args - Values to substitute into the message placeholders.
     */
    warn(obj: object, message?: string, ...args: any[]): void;
    warn(message: string, ...args: any[]): void;
    /**
     * Logs a message at the 'info' level.
     * @param {object} obj - An object with properties to be included in the log.
     * @param {string} [message] - The log message, with optional format placeholders.
     * @param {...any[]} args - Values to substitute into the message placeholders.
     */
    info(obj: object, message?: string, ...args: any[]): void;
    info(message: string, ...args: any[]): void;
    /**
     * Logs a message at the 'debug' level.
     * @param {object} obj - An object with properties to be included in the log.
     * @param {string} [message] - The log message, with optional format placeholders.
     * @param {...any[]} args - Values to substitute into the message placeholders.
     */
    debug(obj: object, message?: string, ...args: any[]): void;
    debug(message: string, ...args: any[]): void;
    /**
     * Logs a message at the 'trace' level.
     * @param {object} obj - An object with properties to be included in the log.
     * @param {string} [message] - The log message, with optional format placeholders.
     * @param {...any[]} args - Values to substitute into the message placeholders.
     */
    trace(obj: object, message?: string, ...args: any[]): void;
    trace(message: string, ...args: any[]): void;
    /**
     * Creates a new child logger instance with bindings that will be present in every log.
     * The child inherits all settings from the parent, adding or overriding the specified bindings.
     * @param {Record<string, any>} bindings - Key-value pairs to bind to the child logger.
     * @returns {ILogger} A new `ILogger` instance.
     */
    child(bindings: Record<string, any>): ILogger;
    /**
     * Dynamically updates the minimum log level for this logger instance.
     * Any messages with a severity lower than the new level will be ignored.
     * @param {LogLevel} level - The new log level to set.
     */
    setLevel(level: LogLevel): void;
    /**
     * Creates a new logger instance with a `source` field bound to it.
     * This is useful for creating a logger for a specific module or component.
     * @param {string} source - The name of the source (e.g., 'redis', 'AuthModule').
     * @returns {ILogger} A new `ILogger` instance with the `source` binding.
     */
    withSource(source: string): ILogger;
    /**
     * Creates a new logger instance with a `retention` field bound to it.
     * The provided rules object will be deep-cloned to ensure immutability.
     * @param {Record<string, any>} rules - A JSON object containing the retention rules.
     * @returns {ILogger} A new `ILogger` instance with the `retention` binding.
     */
    withRetention(rules: Record<string, any>): ILogger;
    /**
     * Creates a new logger instance with a `transactionId` field bound to it.
     * This is useful for tracking a request across multiple services.
     * @param {string} transactionId - The unique ID of the transaction.
     * @returns {ILogger} A new `ILogger` instance with the `transactionId` binding.
     */
    withTransactionId(transactionId: string): ILogger;
}

/**
 * @interface IContextManager
 * @description The contract for managing asynchronous context.
 */
interface IContextManager {
    /**
     * Configures the context manager with specific options.
     * This should be called once during initialization.
     * @param options The configuration options.
     * @param options.correlationIdHeader The custom header name to use for the correlation ID.
     * @param options.transactionIdHeader The custom header name for the transaction ID.
     */
    configure(options: any): void;
    /**
     * Executes a function within a new, isolated asynchronous context.
     * The new context can inherit data from the parent context.
     * @template T The return type of the callback function.
     * @param callback The function to execute within the new context.
     * @returns The return value of the callback function.
     */
    run(fn: () => void | Promise<void>): Promise<void>;
    /**
     * Sets a value in the current asynchronous context.
     * @param key The key for the value.
     * @param value The value to store.
     */
    set(key: string, value: any): void;
    /**
     * Gets a value from the current asynchronous context.
     * @template T The expected type of the value.
     * @param key The key of the value to retrieve.
     * @returns The value associated with the key, or `undefined` if not found.
     */
    get(key: string): any;
    /**
     * Gets the entire key-value store from the current context.
     * @returns {Record<string, any>} An object containing all context data.
     */
    getAll(): Record<string, any>;
    /**
     * A convenience method to get the correlation ID from the current context.
     * @returns {string | undefined} The correlation ID, or undefined if not set.
     */
    getCorrelationId(): string | undefined;
    /**
     * Gets the configured HTTP header name used for the correlation ID.
     * @returns {string} The header name.
     */
    getCorrelationIdHeaderName(): string;
    /**
     * Gets the configured HTTP header name used for the transaction ID.
     * @returns {string} The header name.
     */
    getTransactionIdHeaderName(): string;
    /**
     * A convenience method to get the transaction ID from the current context.
     * @returns {string | undefined} The transaction ID, or undefined if not set.
     */
    getTransactionId(): string | undefined;
    /**
     * A convenience method to set the transaction ID in the current context.
     * @param transactionId The transaction ID to set.
     */
    setTransactionId(transactionId: string): void;
    /** Gets the tracing headers to propagate the context (e.g., W3C Trace Context). */
    getTraceContextHeaders(): Record<string, string>;
    /**
     * Gets a filtered context based on the specified log level.
     * This is useful for logging purposes to ensure only relevant context is included.
     * @param level The log level to filter by.
     * @returns A record containing only the context data relevant for the specified level.
     */
    getFilteredContext(level: LogLevel): Record<string, unknown>;
}

/**
 * @file src/serialization/SerializerRegistry.ts
 * @description Manages and safely applies custom log object serializers.
 */

/**
 * @type SerializerMap
 * @description A map where the key is the field name to look for in a log object,
 * and the value is the function that will transform its value into a string.
 */
type SerializerMap = Record<string, (value: unknown) => string>;
/**
 * @interface SerializerRegistryOptions
 * @description Defines the configuration for the SerializerRegistry.
 */
interface SerializerRegistryOptions {
    /** A map of custom serializer functions provided by the user. */
    serializers?: SerializerMap;
    /** The maximum time in milliseconds a serializer can run before being timed out. @default 50 */
    timeoutMs?: number;
}
/**
 * @class SerializerRegistry
 * @description Manages and applies custom serializer functions to log metadata.
 * It ensures that serializers are executed safely, with timeouts and error handling,
 * to prevent them from destabilizing the logging pipeline.
 */
declare class SerializerRegistry {
    /** @private A map of field names to their corresponding serializer functions. */
    private readonly serializers;
    /** @private The timeout in milliseconds for each serializer execution. */
    private readonly timeoutMs;
    /**
     * @constructor
     * @param {SerializerRegistryOptions} [options] - Configuration options for the registry.
     */
    constructor(options?: SerializerRegistryOptions);
    /**
     * Processes a metadata object, applying any matching serializers.
     * @param {Record<string, unknown>} meta - The metadata object from a log call.
     * @param {ILogger} logger - A logger instance to report errors from the serialization process itself.
     * @returns {Promise<Record<string, unknown>>} A new metadata object with serialized values.
     */
    process(meta: Record<string, unknown>, logger: ILogger): Promise<Record<string, unknown>>;
    /**
     * @private
     * Safely executes a serializer function with a timeout.
     * @param {(value: unknown) => string} serializerFn - The serializer function to execute.
     * @param {unknown} value - The value to pass to the function.
     * @returns {Promise<string>} A promise that resolves with the serialized string.
     * @throws An error if the serializer throws an exception or times out.
     */
    private secureExecute;
    /**
     * @private
     * The default serializer for Error objects. It creates a JSON string representation
     * of the error, explicitly including common properties like name, message, and stack.
     * @param {unknown} err - The value to serialize, expected to be an Error.
     * @returns {string} A JSON string representing the error.
     */
    private defaultErrorSerializer;
}

/**
 * @file src/http/InstrumentedHttpClient.ts
 * @description This class is the heart of the HTTP instrumentation architecture.
 * It wraps any adapter that complies with `IHttpClientAdapter` and adds a centralized
 * layer of instrumentation (logging, context, timers).
 */

/**
 * @class InstrumentedHttpClient
 * @description Wraps an `IHttpClientAdapter` to provide automatic logging,
 * context propagation, and timing for all HTTP requests.
 */
declare class InstrumentedHttpClient {
    private readonly adapter;
    private readonly logger;
    private readonly contextManager;
    private readonly config;
    readonly instanceName: string;
    private readonly instrumentorOptions;
    /**
     * @constructor
     * @param {IHttpClientAdapter} adapter - The underlying HTTP client adapter (e.g., AxiosAdapter).
     * @param {ILogger} logger - The logger instance for this client.
     * @param {IContextManager} contextManager - The manager for handling asynchronous contexts.
     * @param {HttpClientInstanceConfig} config - The configuration for this specific instance.
     */
    constructor(adapter: IHttpClientAdapter, logger: ILogger, contextManager: IContextManager, config: HttpClientInstanceConfig);
    /**
     * The single public method. It executes an HTTP request through the wrapped
     * adapter, applying all instrumentation logic.
     * @template T The expected type of the response data.
     * @param {AdapterHttpRequest} request - The generic HTTP request to execute.
     * @returns {Promise<AdapterHttpResponse<T>>} A promise that resolves with the normalized response.
     * @throws {AdapterHttpError | Error} Throws the error from the adapter, which is re-thrown after being logged.
     */
    request<T>(request: AdapterHttpRequest): Promise<AdapterHttpResponse<T>>;
    /**
     * @private
     * Logs the start of an HTTP request, respecting the configured options.
     * @param {AdapterHttpRequest} request - The outgoing request.
     */
    private logRequestStart;
    /**
     * @private
     * Logs the successful completion of an HTTP request.
     * @template T
     * @param {AdapterHttpRequest} request - The original request.
     * @param {AdapterHttpResponse<T>} response - The received response.
     * @param {number} durationMs - The total duration of the request in milliseconds.
     */
    private logRequestSuccess;
    /**
     * @private
     * Logs the failure of an HTTP request.
     * @param {AdapterHttpRequest} request - The original request.
     * @param {unknown} error - The error that was thrown.
     * @param {number} durationMs - The total duration of the request until failure.
     */
    private logRequestFailure;
}

/**
 * @file src/brokers/InstrumentedBrokerClient.ts
 * @description The core instrumentation class. It wraps any `IBrokerAdapter`
 * implementation and adds logging and automatic context propagation for
 * distributed tracing.
 */

/**
 * @class InstrumentedBrokerClient
 * @description Wraps a user-provided broker adapter to automatically handle
 * logging, context propagation, and distributed tracing.
 */
declare class InstrumentedBrokerClient {
    private readonly adapter;
    private readonly logger;
    private readonly contextManager;
    private readonly config;
    readonly instanceName: string;
    /**
     * @constructor
     * @param {IBrokerAdapter} adapter - The concrete broker adapter implementation (e.g., for RabbitMQ, Kafka).
     * @param {ILogger} logger - The logger instance for this client.
     * @param {IContextManager} contextManager - The manager for handling asynchronous contexts.
     * @param {BrokerInstanceConfig} config - The configuration for this specific instance.
     */
    constructor(adapter: IBrokerAdapter, logger: ILogger, contextManager: IContextManager, config: BrokerInstanceConfig);
    /**
     * Establishes a connection to the broker, wrapping the adapter's connect
     * method with logging.
     * @returns {Promise<void>}
     */
    connect(): Promise<void>;
    /**
     * Disconnects from the broker, wrapping the adapter's disconnect method
     * with logging.
     * @returns {Promise<void>}
     */
    disconnect(): Promise<void>;
    /**
     * Publishes a message, automatically injecting the current `correlation-id`
     * from the active context into the message headers.
     * @param {string} topic - The destination topic or routing key for the message.
     * @param {BrokerMessage} message - The message to be published. The `correlation-id`
     * will be added to its headers if not present.
     * @returns {Promise<void>}
     */
    publish(topic: string, message: BrokerMessage): Promise<void>;
    /**
     * Subscribes to a topic. It wraps the user's message handler to automatically
     * create a new asynchronous context for each incoming message. If a `correlation-id`
     * is found in the message headers, it is used to initialize the new context.
     * @param {string} topic - The topic or queue to subscribe to.
     * @param {MessageHandler} handler - The user-provided function to process incoming messages.
     * @returns {Promise<void>}
     */
    subscribe(topic: string, handler: MessageHandler): Promise<void>;
}

/**
 * FILE: src/redis/redis.types.ts
 * DESCRIPTION: Defines fundamental types extracted from `redis@v4` for use throughout the library.
 */

/**
 * Represents a Redis client instance, which can be either a single-node (standalone) or a cluster client.
 * This is the core client type used internally by `BeaconRedis` and `RedisManager`.
 */
type NodeRedisClient = RedisClientType<RedisModules, RedisFunctions, RedisScripts> | RedisClusterType<RedisModules, RedisFunctions, RedisScripts>;
/**
 * Defines the structure of a Sorted Set member when returned with its score.
 */
type RedisZMember = {
    score: number;
    value: string;
};
/**
 * Represents the native transaction (multi) object from the `redis` client.
 * It is extracted using `ReturnType` to ensure it always matches the native library's type.
 */
type RedisTransaction = ReturnType<NodeRedisClient['multi']>;
/**
 * Represents the result of a transaction's execution (EXEC).
 * It is an array containing the results of each command within the transaction.
 */
type TransactionResult = Awaited<ReturnType<RedisTransaction['exec']>>;

/**
 * @class RedisConnectionManager
 * Handles the state and lifecycle of a single native `node-redis` client.
 * It abstracts away the complexities of connection states, retries, and events,
 * providing a stable and predictable promise-based interface for connecting and disconnecting.
 */
declare class RedisConnectionManager {
    readonly instanceName: string;
    private readonly client;
    private readonly logger;
    private connectionPromise;
    private connectionResolve;
    private connectionReject;
    private isConnectedAndReadyState;
    private isQuitState;
    /**
     * Constructs a new RedisConnectionManager.
     * @param {RedisClientOptions | RedisClusterOptions} options - The configuration options for the native `redis` client.
     * @param {ILogger} logger - The logger instance for logging connection events.
     */
    constructor(config: RedisInstanceConfig, logger: ILogger);
    /**
     * Creates a native Redis client based on the instance configuration mode.
     * @param config The configuration for the specific Redis instance.
     * @returns A `NodeRedisClient` (either single-node or cluster).
     */
    private createNativeClient;
    /**
     * Sets up all the necessary event listeners on the native Redis client
     * to manage and report on the connection's lifecycle state.
     * @private
     */
    private setupListeners;
    /**
     * Initiates a connection to the Redis server.
     * This method is idempotent; it will not attempt to reconnect if already connected
     * or if a connection attempt is already in progress.
     * @returns {Promise<void>} A promise that resolves when the client is connected and ready, or rejects on a connection error.
     */
    connect(): Promise<void>;
    /**
     * Ensures the client is connected and ready before proceeding.
     * This is the primary method that should be awaited before executing a command.
     * @returns {Promise<void>} A promise that resolves when the client is ready, or rejects if it can't connect.
     */
    ensureReady(): Promise<void>;
    /**
     * Gracefully closes the connection to the Redis server by calling `quit()`.
     * It also sets an internal state to prevent any further operations or reconnections.
     * @returns {Promise<void>} A promise that resolves when the client has been successfully quit.
     */
    disconnect(): Promise<void>;
    /**
     * Retrieves the underlying native `node-redis` client instance.
     * @returns {NodeRedisClient} The native client instance.
     */
    getNativeClient(): NodeRedisClient;
    /**
     * Checks if the client is currently connected and ready to accept commands.
     * @returns {boolean} `true` if the client is ready, `false` otherwise.
     */
    isReady(): boolean;
    /**
     * Performs a health check by sending a PING command to the server.
     * @returns {Promise<boolean>} A promise that resolves to `true` if the server responds correctly, `false` otherwise.
     */
    isHealthy(): Promise<boolean>;
    /**
     * Checks if the disconnect (`quit`) process has been initiated for this client.
     * @returns {boolean} `true` if `disconnect` has been called, `false` otherwise.
     */
    isQuit(): boolean;
    /**
     * Executes the Redis PING command.
     * Provides a fallback for cluster mode, as PING is not a standard cluster command.
     */
    ping(message?: string): Promise<string>;
    /**
     * Executes the Redis INFO command.
     * Provides a fallback for cluster mode.
     */
    info(section?: string): Promise<string>;
    /**
     * Executes the Redis EXISTS command.
     * @param {string | string[]} keys - A single key or an array of keys to check.
     * @returns {Promise<number>} A promise that resolves with the number of existing keys.
     */
    exists(keys: string | string[]): Promise<number>;
}

type SyntropyLogState = 'NOT_INITIALIZED' | 'INITIALIZING' | 'READY' | 'ERROR' | 'SHUTTING_DOWN' | 'SHUTDOWN';

/**
 * @class SyntropyLog
 * @description The main public entry point for the framework. It follows the
 * Singleton pattern and acts as an EventEmitter to report on its lifecycle,
 * proxying events from its internal LifecycleManager.
 */
declare class SyntropyLog extends EventEmitter {
    private static instance;
    private readonly lifecycleManager;
    private constructor();
    static getInstance(): SyntropyLog;
    getState(): SyntropyLogState;
    init(config: SyntropyLogConfig): Promise<void>;
    shutdown(): Promise<void>;
    getLogger(name?: string): ILogger;
    getRedis(name: string): RedisConnectionManager;
    getHttp(name: string): InstrumentedHttpClient;
    getBroker(name: string): InstrumentedBrokerClient;
    getContextManager(): IContextManager;
    getConfig(): SyntropyLogConfig;
    getFilteredContext(level: LogLevel): Record<string, unknown>;
    getMasker(): MaskingEngine;
    getSerializer(): SerializerRegistry;
    _resetForTesting(): void;
}
/** The singleton instance of the SyntropyLog framework. */
declare const syntropyLog: SyntropyLog;

/**
 * @file src/logger/transports/ConsoleTransport.ts
 * @description A transport that writes logs to the console as JSON strings.
 */

/**
 * @class ConsoleTransport
 * @description A transport that writes logs to the console as a single, serialized JSON string.
 * This format is ideal for log aggregation systems that can parse JSON.
 * @extends {Transport}
 */
declare class ConsoleTransport extends Transport {
    /**
     * @constructor
     * @param {TransportOptions} [options] - Options for the transport, including level, formatter, and a sanitization engine.
     */
    constructor(options?: TransportOptions);
    /**
     * Logs a structured entry to the console as a single JSON string.
     * The entry is first formatted (if a formatter is provided) and then sanitized
     * before being written to the console.
     * @param {LogEntry} entry - The log entry to process.
     * @returns {Promise<void>}
     */
    log(entry: LogEntry): Promise<void>;
}

/**
 * @file src/logger/transports/BaseConsolePrettyTransport.ts
 * @description An abstract base class for console transports that provide colored, human-readable output.
 */

/**
 * @class BaseConsolePrettyTransport
 * @description Provides common functionality for "pretty" console transports,
 * including color handling and console method selection. Subclasses must
 * implement the `formatLogString` method to define the final output format.
 * @extends {Transport}
 */
declare abstract class BaseConsolePrettyTransport extends Transport {
    protected readonly chalk: chalk.Chalk;
    constructor(options?: TransportOptions);
    /**
     * The core log method. It handles common logic and delegates specific
     * formatting to the subclass.
     * @param {LogEntry} entry - The log entry to process.
     * @returns {Promise<void>}
     */
    log(entry: LogEntry): Promise<void>;
    /**
     * Subclasses must implement this method to define the final, formatted
     * string that will be logged to the console.
     * @param {Record<string, any>} logObject - The final log object after formatting.
     * @returns {string} The formatted log string.
     */
    protected abstract formatLogString(logObject: Record<string, any>): string;
    /**
     * Determines which console method to use based on the log level.
     * @param {LogLevel} level - The log level.
     * @returns {Function} The corresponding console method (e.g., console.log).
     */
    protected getConsoleMethod(level: LogLevel): (message?: any, ...optionalParams: any[]) => void;
}

/**
 * @class PrettyConsoleTransport
 * @description A transport that writes logs to the console in a human-readable, colorful format.
 * Ideal for use in development environments.
 * @extends {BaseConsolePrettyTransport}
 */
declare class PrettyConsoleTransport extends BaseConsolePrettyTransport {
    private readonly levelColorMap;
    /**
     * @constructor
     * @param {TransportOptions} [options] - Options for the transport, such as level or a formatter.
     */
    constructor(options?: TransportOptions);
    /**
     * Formats the log object into a pretty, human-readable string.
     * @param {Record<string, any>} logObject - The log object to format.
     * @returns {string} The formatted string.
     */
    protected formatLogString(logObject: Record<string, any>): string;
}

/**
 * @class CompactConsoleTransport
 * A transport that writes logs to the console in a compact, single-line format
 * for metadata, optimized for developer productivity.
 * @extends {BaseConsolePrettyTransport}
 */
declare class CompactConsoleTransport extends BaseConsolePrettyTransport {
    private readonly levelColorMap;
    /**
     * @constructor
     * @param {TransportOptions} [options] - Options for the transport, such as level or a formatter.
     */
    constructor(options?: TransportOptions);
    /**
     * Formats the log object into a compact, human-readable string.
     * @param {Record<string, any>} logObject - The log object to format.
     * @returns {string} The formatted string.
     */
    protected formatLogString(logObject: Record<string, any>): string;
}

/**
 * @file src/logger/transports/ClassicConsoleTransport.ts
 * @description A transport that formats logs in a classic, single-line, text-based format, similar to Log4j.
 */

/**
 * @class ClassicConsoleTransport
 * A transport that writes logs to the console in a classic single-line format,
 * reminiscent of traditional Java logging frameworks.
 * @extends {BaseConsolePrettyTransport}
 */
declare class ClassicConsoleTransport extends BaseConsolePrettyTransport {
    private readonly levelColorMap;
    /**
     * @constructor
     * @param {TransportOptions} [options] - Options for the transport, such as level or a formatter.
     */
    constructor(options?: TransportOptions);
    /**
     * @private
     * Formats a date object into a 'YYYY-MM-DD HH:mm:ss' string.
     * @param {string} ts - The ISO timestamp string to format.
     * @returns {string} The formatted timestamp.
     */
    private formatTimestamp;
    /**
     * Formats the log object into a classic, single-line string.
     * @param {Record<string, any>} logObject - The log object to format.
     * @returns {string} The formatted string.
     */
    protected formatLogString(logObject: Record<string, any>): string;
}

/**
 * @file src/logger/transports/SpyTransport.ts
 * @description A transport designed for testing purposes.
 */

/**
 * @class SpyTransport
 * A transport designed for testing. It captures log entries in memory,
 * allowing you to make assertions on what has been logged.
 * @extends {Transport}
 */
declare class SpyTransport extends Transport {
    private entries;
    /**
     * @constructor
     * @param {TransportOptions} [options] - Options for the transport, such as level.
     */
    constructor(options?: TransportOptions);
    /**
     * Stores the log entry in an in-memory array.
     * @param {LogEntry} entry - The log entry to capture.
     * @returns {Promise<void>}
     */
    log(entry: LogEntry): Promise<void>;
    /**
     * Returns all log entries captured by this transport.
     * @returns {LogEntry[]} A copy of all captured log entries.
     */
    getEntries(): LogEntry[];
    /**
     * Finds log entries where the properties match the given predicate.
     * Note: This performs a shallow comparison on the entry's properties.
     * @param {Partial<LogEntry> | ((entry: LogEntry) => boolean)} predicate - An object with properties to match or a function that returns true for matching entries.
     * @returns {LogEntry[]} An array of matching log entries.
     */
    findEntries(predicate: Partial<LogEntry> | ((entry: LogEntry) => boolean)): LogEntry[];
    /**
     * Clears all captured log entries. Call this in your test setup
     * (e.g., `beforeEach`) to ensure test isolation.
     * @returns {void}
     */
    clear(): void;
    /**
     * Returns the first log entry that was captured.
     * @returns {LogEntry | undefined} The first entry, or undefined if none were captured.
     */
    getFirstEntry(): LogEntry | undefined;
    /**
     * Returns the most recent log entry that was captured.
     * @returns {LogEntry | undefined} The last entry, or undefined if none were captured.
     */
    getLastEntry(): LogEntry | undefined;
}

/**
 * @file src/redis/IBeaconRedis.ts
 * @description Defines the contract for an instrumented Redis client.
 * It exposes common Redis commands and methods for lifecycle management.
 */

/**
 * Defines the contract for a Redis transaction (MULTI/EXEC).
 * All command methods are chainable, returning `this` to queue further commands.
 */
interface IBeaconRedisTransaction {
    /** Queues a GET command. */
    get(key: string): this;
    /** Queues a SET command. */
    set(key: string, value: any, ttlSeconds?: number): this;
    /** Queues a DEL command. */
    del(key: string | string[]): this;
    /** Queues an EXISTS command. */
    exists(keys: string | string[]): this;
    /** Queues an EXPIRE command. */
    expire(key: string, seconds: number): this;
    /** Queues a TTL command. */
    ttl(key: string): this;
    /** Queues an INCR command. */
    incr(key: string): this;
    /** Queues a DECR command. */
    decr(key: string): this;
    /** Queues an INCRBY command. */
    incrBy(key: string, increment: number): this;
    /** Queues a DECRBY command. */
    decrBy(key: string, decrement: number): this;
    /** Queues an HGET command. */
    hGet(key: string, field: string): this;
    /** Queues an HSET command for a single field. */
    hSet(key: string, field: string, value: any): this;
    /** Queues an HSET command for multiple fields. */
    hSet(key: string, fieldsAndValues: Record<string, any>): this;
    /** Queues an HGETALL command. */
    hGetAll(key: string): this;
    /** Queues an HDEL command. */
    hDel(key: string, fields: string | string[]): this;
    /** Queues an HEXISTS command. */
    hExists(key: string, field: string): this;
    /** Queues an HINCRBY command. */
    hIncrBy(key: string, field: string, increment: number): this;
    /** Queues an LPUSH command. */
    lPush(key: string, elements: any | any[]): this;
    /** Queues an RPUSH command. */
    rPush(key: string, elements: any | any[]): this;
    /** Queues an LPOP command. */
    lPop(key: string): this;
    /** Queues an RPOP command. */
    rPop(key: string): this;
    /** Queues an LRANGE command. */
    lRange(key: string, start: number, stop: number): this;
    /** Queues an LLEN command. */
    lLen(key: string): this;
    /** Queues an LTRIM command. */
    lTrim(key: string, start: number, stop: number): this;
    /** Queues an SADD command. */
    sAdd(key: string, members: any | any[]): this;
    /** Queues an SMEMBERS command. */
    sMembers(key: string): this;
    /** Queues an SISMEMBER command. */
    sIsMember(key: string, member: any): this;
    /** Queues an SREM command. */
    sRem(key: string, members: any | any[]): this;
    /** Queues an SCARD command. */
    sCard(key: string): this;
    /** Queues a ZADD command for a single member. */
    zAdd(key: string, score: number, member: any): this;
    /** Queues a ZADD command for multiple members. */
    zAdd(key: string, members: {
        score: number;
        value: any;
    }[]): this;
    /** Queues a ZRANGE command. */
    zRange(key: string, min: string | number, max: string | number, options?: any): this;
    /** Queues a ZRANGE command with scores. */
    zRangeWithScores(key: string, min: string | number, max: string | number, options?: any): this;
    /** Queues a ZREM command. */
    zRem(key: string, members: any | any[]): this;
    /** Queues a ZCARD command. */
    zCard(key: string): this;
    /** Queues a ZSCORE command. */
    zScore(key: string, member: any): this;
    /** Queues a PING command. */
    ping(message?: string): this;
    /** Queues an INFO command. */
    info(section?: string): this;
    /**
     * Executes all queued commands in the transaction.
     * @returns A promise that resolves with an array of results from each command.
     */
    exec(): Promise<TransactionResult>;
    /**
     * Discards the transaction, clearing all queued commands.
     * @returns A promise that resolves when the transaction is discarded.
     */
    discard(): Promise<void>;
}
/**
 * Defines the main interface for an instrumented Redis client, providing a unified API
 * for various Redis commands and lifecycle management.
 */
interface IBeaconRedis {
    /**
     * Gets the configured name of this Redis instance.
     * @returns The instance name.
     */
    getInstanceName(): string;
    /**
     * Dynamically updates the configuration for this Redis instance.
     * @param newConfig A partial configuration object with the new values.
     */
    updateConfig(newConfig: Partial<any>): void;
    /**
     * Establishes a connection to the Redis server if not already connected.
     * @returns {Promise<void>} A promise that resolves when the client is connected and ready.
     */
    connect(): Promise<void>;
    /**
     * Closes the connection to the Redis server.
     * @returns {Promise<void>} A promise that resolves when the connection is successfully closed.
     */
    quit(): Promise<void>;
    /**
     * Initiates a new transaction block (MULTI).
     * @returns {IBeaconRedisTransaction} An instance for queueing commands.
     */
    multi(): IBeaconRedisTransaction;
    /**
     * Gets the value of a key. Corresponds to the Redis GET command.
     * @param {string} key The key to retrieve.
     * @returns {Promise<string | null>} A promise that resolves with the value of the key, or null if the key does not exist.
     */
    get(key: string): Promise<string | null>;
    /**
     * Sets the string value of a key. Corresponds to the Redis SET command.
     * @param {string} key The key to set.
     * @param {string} value The value to set for the key.
     * @param {number} [ttlSeconds] Optional. The time-to-live for the key in seconds.
     * @returns {Promise<string | null>} A promise that resolves with 'OK' on success.
     */
    set(key: string, value: string, ttlSeconds?: number): Promise<string | null>;
    /**
     * Deletes one or more keys. Corresponds to the Redis DEL command.
     * @param {string | string[]} keys A single key or an array of keys to delete.
     * @returns {Promise<number>} A promise that resolves with the number of keys that were deleted.
     */
    del(keys: string | string[]): Promise<number>;
    /**
     * Determines if one or more keys exist. Corresponds to the Redis EXISTS command.
     * @param {string | string[]} keys A single key or an array of keys to check.
     * @returns {Promise<number>} A promise that resolves with the number of keys that exist.
     */
    exists(keys: string | string[]): Promise<number>;
    /**
     * Sets a key's time to live in seconds. Corresponds to the Redis EXPIRE command.
     * @param {string} key The key to set the expiration for.
     * @param {number} seconds The time-to-live in seconds.
     * @returns {Promise<boolean>} A promise that resolves with true if the timeout was set, false otherwise.
     */
    expire(key: string, seconds: number): Promise<boolean>;
    /**
     * Gets the time to live for a key. Corresponds to the Redis TTL command.
     * @param {string} key The key to check.
     * @returns {Promise<number>} A promise that resolves with the remaining time to live in seconds.
     */
    ttl(key: string): Promise<number>;
    /**
     * Increments the integer value of a key by one. Corresponds to the Redis INCR command.
     * @param {string} key The key to increment.
     * @returns {Promise<number>} A promise that resolves with the value of the key after the increment.
     */
    incr(key: string): Promise<number>;
    /**
     * Decrements the integer value of a key by one. Corresponds to the Redis DECR command.
     * @param {string} key The key to decrement.
     * @returns {Promise<number>} A promise that resolves with the value of the key after the decrement.
     */
    decr(key: string): Promise<number>;
    /**
     * Increments the integer value of a key by the given amount. Corresponds to the Redis INCRBY command.
     * @param {string} key The key to increment.
     * @param {number} increment The amount to increment by.
     * @returns {Promise<number>} A promise that resolves with the value of the key after the increment.
     */
    incrBy(key: string, increment: number): Promise<number>;
    /**
     * Decrements the integer value of a key by the given amount. Corresponds to the Redis DECRBY command.
     * @param {string} key The key to decrement.
     * @param {number} decrement The amount to decrement by.
     * @returns {Promise<number>} A promise that resolves with the value of the key after the decrement.
     */
    decrBy(key: string, decrement: number): Promise<number>;
    /**
     * Gets the value of a hash field. Corresponds to the Redis HGET command.
     * @param {string} key The key of the hash.
     * @param {string} field The field to get from the hash.
     * @returns {Promise<string | null>} A promise that resolves with the value of the field, or null if the field or key does not exist.
     */
    hGet(key: string, field: string): Promise<string | null>;
    /**
     * Sets the string value of a hash field. Corresponds to the Redis HSET command.
     * @param {string} key The key of the hash.
     * @param {string} field The field to set in the hash.
     * @param {any} value The value to set for the field.
     * @returns {Promise<number>} A promise that resolves with the number of fields that were added.
     */
    hSet(key: string, field: string, value: any): Promise<number>;
    /**
     * Sets multiple hash fields to multiple values. Corresponds to the Redis HSET command.
     * @param {string} key The key of the hash.
     * @param {Record<string, any>} fieldsAndValues An object of field-value pairs to set.
     * @returns {Promise<number>} A promise that resolves with the number of fields that were added.
     */
    hSet(key: string, fieldsAndValues: Record<string, any>): Promise<number>;
    /**
     * Gets all the fields and values in a hash. Corresponds to the Redis HGETALL command.
     * @param {string} key The key of the hash.
     * @returns {Promise<Record<string, string>>} A promise that resolves with an object containing all fields and values.
     */
    hGetAll(key: string): Promise<Record<string, string>>;
    /**
     * Deletes one or more hash fields. Corresponds to the Redis HDEL command.
     * @param {string} key The key of the hash.
     * @param {string | string[]} fields The field or fields to delete.
     * @returns {Promise<number>} A promise that resolves with the number of fields that were removed.
     */
    hDel(key: string, fields: string | string[]): Promise<number>;
    /**
     * Determines if a hash field exists. Corresponds to the Redis HEXISTS command.
     * @param {string} key The key of the hash.
     * @param {string} field The field to check.
     * @returns {Promise<boolean>} A promise that resolves with true if the field exists, false otherwise.
     */
    hExists(key: string, field: string): Promise<boolean>;
    /**
     * Increments the integer value of a hash field by the given number. Corresponds to the Redis HINCRBY command.
     * @param {string} key The key of the hash.
     * @param {string} field The field to increment.
     * @param {number} increment The amount to increment by.
     * @returns {Promise<number>} A promise that resolves with the value of the field after the increment.
     */
    hIncrBy(key: string, field: string, increment: number): Promise<number>;
    /**
     * Prepends one or multiple values to a list. Corresponds to the Redis LPUSH command.
     * @param {string} key The key of the list.
     * @param {any | any[]} elements The value or values to prepend.
     * @returns {Promise<number>} A promise that resolves with the length of the list after the push operation.
     */
    lPush(key: string, elements: any | any[]): Promise<number>;
    /**
     * Appends one or multiple values to a list. Corresponds to the Redis RPUSH command.
     * @param {string} key The key of the list.
     * @param {any | any[]} elements The value or values to append.
     * @returns {Promise<number>} A promise that resolves with the length of the list after the push operation.
     */
    rPush(key: string, elements: any | any[]): Promise<number>;
    /**
     * Removes and gets the first element in a list. Corresponds to the Redis LPOP command.
     * @param {string} key The key of the list.
     * @returns {Promise<string | null>} A promise that resolves with the value of the first element, or null if the list is empty.
     */
    lPop(key: string): Promise<string | null>;
    /**
     * Removes and gets the last element in a list. Corresponds to the Redis RPOP command.
     * @param {string} key The key of the list.
     * @returns {Promise<string | null>} A promise that resolves with the value of the last element, or null if the list is empty.
     */
    rPop(key: string): Promise<string | null>;
    /**
     * Gets a range of elements from a list. Corresponds to the Redis LRANGE command.
     * @param {string} key The key of the list.
     * @param {number} start The starting index.
     * @param {number} stop The ending index.
     * @returns {Promise<string[]>} A promise that resolves with an array of elements in the specified range.
     */
    lRange(key: string, start: number, stop: number): Promise<string[]>;
    /**
     * Gets the length of a list. Corresponds to the Redis LLEN command.
     * @param {string} key The key of the list.
     * @returns {Promise<number>} A promise that resolves with the length of the list.
     */
    lLen(key: string): Promise<number>;
    /**
     * Trims a list to the specified range. Corresponds to the Redis LTRIM command.
     * @param {string} key The key of the list.
     * @param {number} start The starting index.
     * @param {number} stop The ending index.
     * @returns {Promise<string>} A promise that resolves with 'OK'.
     */
    lTrim(key: string, start: number, stop: number): Promise<string>;
    /**
     * Adds one or more members to a set. Corresponds to the Redis SADD command.
     * @param {string} key The key of the set.
     * @param {any | any[]} members The member or members to add.
     * @returns {Promise<number>} A promise that resolves with the number of members that were added to the set.
     */
    sAdd(key: string, members: any | any[]): Promise<number>;
    /**
     * Gets all the members in a set. Corresponds to the Redis SMEMBERS command.
     * @param {string} key The key of the set.
     * @returns {Promise<string[]>} A promise that resolves with an array of all the members in the set.
     */
    sMembers(key: string): Promise<string[]>;
    /**
     * Determines if a given value is a member of a set. Corresponds to the Redis SISMEMBER command.
     * @param {string} key The key of the set.
     * @param {any} member The member to check for.
     * @returns {Promise<boolean>} A promise that resolves with true if the member exists in the set, false otherwise.
     */
    sIsMember(key: string, member: any): Promise<boolean>;
    /**
     * Removes one or more members from a set. Corresponds to the Redis SREM command.
     * @param {string} key The key of the set.
     * @param {any | any[]} members The member or members to remove.
     * @returns {Promise<number>} A promise that resolves with the number of members that were removed from the set.
     */
    sRem(key: string, members: any | any[]): Promise<number>;
    /**
     * Gets the number of members in a set. Corresponds to the Redis SCARD command.
     * @param {string} key The key of the set.
     * @returns {Promise<number>} A promise that resolves with the number of members in the set.
     */
    sCard(key: string): Promise<number>;
    /**
     * Adds a member to a sorted set, or updates its score if it already exists. Corresponds to the Redis ZADD command.
     * @param {string} key The key of the sorted set.
     * @param {number} score The score for the member.
     * @param {any} member The member to add.
     * @returns {Promise<number>} A promise that resolves with the number of elements added to the sorted set.
     */
    zAdd(key: string, score: number, member: any): Promise<number>;
    /**
     * Adds multiple members to a sorted set, or updates their scores if they already exist. Corresponds to the Redis ZADD command.
     * @param {string} key The key of the sorted set.
     * @param {{ score: number; value: any }[]} members An array of member-score objects to add.
     * @returns {Promise<number>} A promise that resolves with the number of elements added to the sorted set.
     */
    zAdd(key: string, members: {
        score: number;
        value: any;
    }[]): Promise<number>;
    /**
     * Returns a range of members in a sorted set, by index. Corresponds to the Redis ZRANGE command.
     * @param {string} key The key of the sorted set.
     * @param {string | number} min The minimum index or score.
     * @param {string | number} max The maximum index or score.
     * @param {any} [options] Additional options (e.g., { REV: true }).
     * @returns {Promise<string[]>} A promise that resolves with an array of members in the specified range.
     */
    zRange(key: string, min: string | number, max: string | number, options?: any): Promise<string[]>;
    /**
     * Returns a range of members in a sorted set, by index, with scores. Corresponds to the Redis ZRANGE command with WITHSCORES.
     * @param {string} key The key of the sorted set.
     * @param {string | number} min The minimum index or score.
     * @param {string | number} max The maximum index or score.
     * @param {any} [options] Additional options (e.g., { REV: true }).
     * @returns {Promise<RedisZMember[]>} A promise that resolves with an array of members and their scores.
     */
    zRangeWithScores(key: string, min: string | number, max: string | number, options?: any): Promise<RedisZMember[]>;
    /**
     * Removes one or more members from a sorted set. Corresponds to the Redis ZREM command.
     * @param {string} key The key of the sorted set.
     * @param {any | any[]} members The member or members to remove.
     * @returns {Promise<number>} A promise that resolves with the number of members removed.
     */
    zRem(key: string, members: any | any[]): Promise<number>;
    /**
     * Gets the number of members in a sorted set. Corresponds to the Redis ZCARD command.
     * @param {string} key The key of the sorted set.
     * @returns {Promise<number>} A promise that resolves with the sorted set's cardinality.
     */
    zCard(key: string): Promise<number>;
    /**
     * Gets the score associated with the given member in a sorted set. Corresponds to the Redis ZSCORE command.
     * @param {string} key The key of the sorted set.
     * @param {any} member The member whose score to retrieve.
     * @returns {Promise<number | null>} A promise that resolves with the score of the member, or null if the member does not exist.
     */
    zScore(key: string, member: any): Promise<number | null>;
    /**
     * Pings the server. Corresponds to the Redis PING command.
     * @param {string} [message] An optional message to include in the ping.
     * @returns {Promise<string>} A promise that resolves with 'PONG' or the provided message.
     */
    ping(message?: string): Promise<string>;
    /**
     * Gets information and statistics about the server. Corresponds to the Redis INFO command.
     * @param {string} [section] An optional section to query (e.g., 'server', 'clients').
     * @returns {Promise<string>} A promise that resolves with a string containing the server information.
     */
    info(section?: string): Promise<string>;
}

export { ClassicConsoleTransport, CompactConsoleTransport, ConsoleTransport, MaskingEngine, PrettyConsoleTransport, SanitizationEngine, SpyTransport, SyntropyLog, Transport, syntropyLog };
export type { BrokerMessage, IBeaconRedis, IBrokerAdapter, IContextManager, IHttpClientAdapter, ILogger, JsonValue, LogEntry, LogFormatter, LogLevel, LoggerOptions, MessageHandler, MessageLifecycleControls, SyntropyLogConfig };
