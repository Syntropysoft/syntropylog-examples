import { EventEmitter } from 'events';
import { z, ZodError } from 'zod';
import { AsyncLocalStorage } from 'node:async_hooks';
import { randomUUID } from 'crypto';
import * as util from 'node:util';
import RegexTest from 'regex-test';
import { createClient } from 'redis';
import chalk from 'chalk';

/**
 * @file src/logger/levels.ts
 * @description Defines the available log levels, their names, and their severity weights.
 */
/**
 * @description A mapping of log level names to their severity weights.
 * Higher numbers indicate higher severity.
 */
const LOG_LEVEL_WEIGHTS = {
    fatal: 60,
    error: 50,
    warn: 40,
    info: 30,
    debug: 20,
    trace: 10,
    silent: 0,
};

/**
 * @file src/logger/transports/Transport.ts
 * @description Defines the abstract base class for all log transports.
 */
/**
 * @class Transport
 * @description The abstract base class for all log transports. A transport is
 * responsible for the final output of a log entry, whether it's to the console,
 * a file, or a remote service.
 */
class Transport {
    level;
    name;
    /** The formatter instance to transform log entries. */
    formatter;
    /** The engine used to sanitize sensitive data. */
    sanitizationEngine;
    /**
     * @constructor
     * @param {TransportOptions} [options] - The configuration options for this transport.
     */
    constructor(options = {}) {
        this.level = options.level ?? 'info';
        this.name = options.name ?? this.constructor.name;
        this.formatter = options?.formatter;
        this.sanitizationEngine = options?.sanitizationEngine;
    }
    /**
     * Determines if the transport should process a log entry based on its log level.
     * @param level - The level of the log entry to check.
     * @returns {boolean} - True if the transport is enabled for this level, false otherwise.
     */
    isLevelEnabled(level) {
        return LOG_LEVEL_WEIGHTS[level] >= LOG_LEVEL_WEIGHTS[this.level];
    }
    /**
     * A method to ensure all buffered logs are written before the application exits.
     * Subclasses should override this if they perform I/O buffering.
     * @returns {Promise<void>} A promise that resolves when flushing is complete.
     */
    async flush() {
        // Default implementation does nothing, assuming no buffering.
        return Promise.resolve();
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * FILE: src/config.schema.ts
 * DESCRIPTION: Defines the Zod validation schemas for the entire library's configuration.
 * These schemas are the single source of truth for the configuration's structure and types.
 */
/**
 * @description Schema for logger-specific options, including serialization and transports.
 * @private
 */
const loggerOptionsSchema = z
    .object({
    name: z.string().optional(),
    level: z
        .enum(['fatal', 'error', 'warn', 'info', 'debug', 'trace', 'silent'])
        .optional(),
    serviceName: z.string().optional(),
    /**
     * An array of transport instances to be used by the logger.
     */
    transports: z.array(z.instanceof(Transport)).optional(),
    /**
     * A dictionary of custom serializer functions. The key is the field
     * to look for in the log object, and the value is the function that transforms it.
     */
    serializers: z
        .record(z.string(), z.function().args(z.any()).returns(z.string()))
        .optional(),
    /**
     * The maximum time in milliseconds a custom serializer can run before being timed out.
     * @default 50
     */
    serializerTimeoutMs: z.number().int().positive().default(50),
    /** Configuration for pretty printing logs in development. */
    prettyPrint: z
        .object({
        enabled: z.boolean().optional().default(false),
    })
        .optional(),
})
    .optional();
/**
 * @description Reusable schema for retry options, commonly used in client configurations.
 * @private
 */
const retryOptionsSchema = z
    .object({
    maxRetries: z.number().int().positive().optional(),
    retryDelay: z.number().int().positive().optional(),
})
    .optional();
/**
 * @description Schema for a single Redis instance, using a discriminated union for different connection modes.
 */
const redisInstanceConfigSchema = z.discriminatedUnion('mode', [
    z.object({
        mode: z.literal('single'),
        instanceName: z.string(),
        url: z.string().url(),
        retryOptions: retryOptionsSchema,
        // --- NEW: Granular Logging Configuration for Redis ---
        logging: z
            .object({
            /** Level for successful commands. @default 'debug' */
            onSuccess: z.enum(['trace', 'debug', 'info']).default('debug'),
            /** Level for failed commands. @default 'error' */
            onError: z.enum(['warn', 'error', 'fatal']).default('error'),
            /** Whether to log command parameters. @default true */
            logCommandValues: z.boolean().default(true),
            /** Whether to log the return value of commands. @default false */
            logReturnValue: z.boolean().default(false),
        })
            .optional(),
    }),
    // Apply the same 'logging' object structure to 'sentinel' and 'cluster' modes
    z.object({
        mode: z.literal('sentinel'),
        instanceName: z.string(),
        name: z.string(),
        sentinels: z.array(z.object({ host: z.string(), port: z.number() })),
        sentinelPassword: z.string().optional(),
        retryOptions: retryOptionsSchema,
        logging: z
            .object({
            onSuccess: z.enum(['trace', 'debug', 'info']).default('debug'),
            onError: z.enum(['warn', 'error', 'fatal']).default('error'),
            logCommandValues: z.boolean().default(true),
            logReturnValue: z.boolean().default(false),
        })
            .optional(),
    }),
    z.object({
        mode: z.literal('cluster'),
        instanceName: z.string(),
        rootNodes: z.array(z.object({ host: z.string(), port: z.number() })),
        logging: z
            .object({
            /** Level for successful commands. @default 'debug' */
            onSuccess: z.enum(['trace', 'debug', 'info']).default('debug'),
            /** Level for failed commands. @default 'error' */
            onError: z.enum(['warn', 'error', 'fatal']).default('error'),
            /** Whether to log command parameters. @default true */
            logCommandValues: z.boolean().default(true),
            /** Whether to log the return value of commands. @default false */
            logReturnValue: z.boolean().default(false),
        })
            .optional(),
    }),
]);
/**
 * @description Schema for the main Redis configuration block, containing all Redis instances.
 */
const redisConfigSchema = z
    .object({
    /** An array of Redis instance configurations. */
    instances: z.array(redisInstanceConfigSchema),
    /** The name of the default Redis instance to use when no name is provided to `getInstance()`. */
    default: z.string().optional(),
})
    .optional();
/**
 * @description Schema for a single HTTP client instance.
 */
const httpInstanceConfigSchema = z.object({
    instanceName: z.string(),
    adapter: z.custom((val) => {
        return (typeof val === 'object' &&
            val !== null &&
            'request' in val &&
            typeof val.request === 'function');
    }, "The provided adapter is invalid. It must be an object with a 'request' method."),
    isDefault: z.boolean().optional(),
    propagate: z.array(z.string()).optional(),
    propagateFullContext: z.boolean().optional(),
    logging: z
        .object({
        onSuccess: z.enum(['trace', 'debug', 'info']).default('info'),
        onError: z.enum(['warn', 'error', 'fatal']).default('error'),
        logSuccessBody: z.boolean().default(false),
        logSuccessHeaders: z.boolean().default(false),
        onRequest: z.enum(['trace', 'debug', 'info']).default('info'),
        logRequestBody: z.boolean().default(false),
        logRequestHeaders: z.boolean().default(false),
    })
        .partial()
        .optional(),
});
/**
 * @description Schema for the main HTTP configuration block.
 */
const httpConfigSchema = z
    .object({
    /** An array of HTTP client instance configurations. */
    instances: z.array(httpInstanceConfigSchema),
    /** The name of the default HTTP client instance to use when no name is provided to `getInstance()`. */
    default: z.string().optional(),
})
    .optional();
/**
 * @description Schema for the main data masking configuration block.
 */
const maskingConfigSchema = z
    .object({
    /** An array of sensitive field names or RegExp. */
    fields: z.array(z.union([z.string(), z.instanceof(RegExp)])).optional(),
    /** The character(s) to use for masking. If `style` is 'preserve-length', only the first character is used. */
    maskChar: z.string().optional(),
    /** The maximum recursion depth for masking nested objects. Defaults to 3. */
    maxDepth: z.number().int().positive().optional(),
    /**
     * The masking style.
     * - `fixed`: (Default) Replaces the value with a fixed-length string ('******'). Maximum security.
     * - `preserve-length`: Replaces the value with a mask string of the same length. Leaks length metadata.
     */
    style: z.enum(['fixed', 'preserve-length']).optional(),
})
    .optional();
/**
 * @description Schema for a single message broker client instance.
 * It validates that a valid `IBrokerAdapter` is provided.
 * @private
 */
const brokerInstanceConfigSchema = z.object({
    instanceName: z.string(),
    adapter: z.custom((val) => {
        return (typeof val === 'object' &&
            val !== null &&
            typeof val.publish === 'function' &&
            typeof val.subscribe === 'function');
    }, 'The provided broker adapter is invalid.'),
    /**
     * An array of context keys to propagate as message headers/properties.
     * To propagate all keys, provide an array with a single wildcard: `['*']`.
     * If not provided, only `correlationId` and `transactionId` are propagated by default.
     */
    propagate: z.array(z.string()).optional(),
    /**
     * @deprecated Use `propagate` instead.
     * If true, propagates the entire asynchronous context map as headers.
     * If false (default), only propagates `correlationId` and `transactionId`.
     */
    propagateFullContext: z.boolean().optional(),
    isDefault: z.boolean().optional(),
});
/**
 * @description Schema for the main message broker configuration block.
 */
const brokerConfigSchema = z
    .object({
    /** An array of broker client instance configurations. */
    instances: z.array(brokerInstanceConfigSchema),
    /** The name of the default broker instance to use when no name is provided to `getInstance()`. */
    default: z.string().optional(),
})
    .optional();
/**
 * @description Schema for the declarative logging matrix.
 * It controls which context properties are included in the final log output based on the log level.
 * @private
 */
const loggingMatrixSchema = z
    .object({
    /** An array of context keys to include in logs by default. Can be overridden by level-specific rules. */
    default: z.array(z.string()).optional(),
    /** An array of context keys to include for 'trace' level logs. Use `['*']` to include all context properties. */
    trace: z.array(z.string()).optional(),
    /** An array of context keys to include for 'debug' level logs. Use `['*']` to include all context properties. */
    debug: z.array(z.string()).optional(),
    /** An array of context keys to include for 'info' level logs. Use `['*']` to include all context properties. */
    info: z.array(z.string()).optional(),
    /** An array of context keys to include for 'warn' level logs. Use `['*']` to include all context properties. */
    warn: z.array(z.string()).optional(),
    /** An array of context keys to include for 'error' level logs. Use `['*']` to include all context properties. */
    error: z.array(z.string()).optional(),
    /** An array of context keys to include for 'fatal' level logs. Use `['*']` to include all context properties. */
    fatal: z.array(z.string()).optional(),
})
    .optional();
/**
 * @description The main schema for the entire SyntropyLog configuration.
 * This is the single source of truth for validating the user's configuration object.
 */
const syntropyLogConfigSchema = z.object({
    /** Logger-specific configuration. */
    logger: loggerOptionsSchema,
    /** Declarative matrix to control context data in logs. */
    loggingMatrix: loggingMatrixSchema,
    /** Redis client configuration. */
    redis: redisConfigSchema,
    /** HTTP client configuration. */
    http: httpConfigSchema,
    /** Message broker client configuration. */
    brokers: brokerConfigSchema,
    /** Centralized data masking configuration. */
    masking: maskingConfigSchema,
    /** Context propagation configuration. */
    context: z
        .object({
        /** The HTTP header name to use for the correlation ID. @default 'x-correlation-id' */
        correlationIdHeader: z.string().optional(),
        /** The HTTP header name to use for the external transaction/trace ID. @default 'x-trace-id' */
        transactionIdHeader: z.string().optional(),
    })
        .optional(),
    /**
     * The maximum time in milliseconds to wait for a graceful shutdown before timing out.
     * @default 5000
     */
    shutdownTimeout: z
        .number({
        description: 'The maximum time in ms to wait for a graceful shutdown.',
    })
        .int()
        .positive()
        .optional(),
    /** Configuration for the `syntropylog doctor` CLI tool. */
    doctor: z
        .object({
        /** An array of rule IDs to disable during a diagnostic run. */
        disableRules: z.array(z.string()).optional(),
    })
        .optional(),
});

/* eslint-disable @typescript-eslint/no-explicit-any */
/*
 * @file src/context/ContextManager.ts
 * @description The default implementation of the IContextManager interface. It uses Node.js's
 * `AsyncLocalStorage` to create and manage asynchronous contexts, enabling
 * seamless propagation of data like correlation IDs across async operations.
 */
/**
 * Manages asynchronous context using Node.js `AsyncLocalStorage`.
 * This is the core component for propagating context-specific data
 * (like correlation IDs) without passing them through function arguments.
 * @implements {IContextManager}
 */
class ContextManager {
    storage = new AsyncLocalStorage();
    correlationIdHeader = 'x-correlation-id';
    transactionIdHeader = 'x-trace-id';
    loggingMatrix;
    constructor(loggingMatrix) {
        this.storage = new AsyncLocalStorage();
        this.loggingMatrix = loggingMatrix;
    }
    configure(options) {
        if (options.correlationIdHeader) {
            this.correlationIdHeader = options.correlationIdHeader;
        }
        if (options.transactionIdHeader) {
            this.transactionIdHeader = options.transactionIdHeader;
        }
    }
    /**
     * Executes a function within a new, isolated asynchronous context.
     * Any data set via `set()` inside the callback will only be available
     * within that callback's asynchronous execution path. The new context
     * inherits values from the parent context, if one exists.
     * @template T The return type of the callback.
     * @param callback The function to execute within the new context.
     * @returns {T} The result of the callback function.
     */
    run(fn) {
        return new Promise((resolve, reject) => {
            const parentContext = this.storage.getStore();
            const newContextData = new Map(parentContext?.data);
            this.storage.run({ data: newContextData }, async () => {
                try {
                    // Initialize correlation ID if not present
                    if (!this.get('correlationId')) {
                        this.set('correlationId', randomUUID());
                    }
                    await Promise.resolve(fn());
                    resolve();
                }
                catch (error) {
                    reject(error);
                }
            });
        });
    }
    /**
     * Gets a value from the current asynchronous context by its key.
     * @template T The expected type of the value.
     * @param key The key of the value to retrieve.
     * @returns The value, or `undefined` if not found or if outside a context.
     */
    get(key) {
        return this.storage.getStore()?.data.get(key);
    }
    /**
     * Gets the entire key-value store from the current asynchronous context.
     * @returns {Record<string, any>} An object containing all context data, or an empty object if outside a context.
     */
    getAll() {
        const store = this.storage.getStore();
        if (!store) {
            return {};
        }
        return Object.fromEntries(store.data.entries());
    }
    /**
     * Sets a key-value pair in the current asynchronous context. This will have
     * no effect if called outside of a context created by `run()`.
     * This will only work if called within a context created by `run()`.
     * @param key The key for the value.
     * @param value The value to store.
     * @returns {void}
     */
    set(key, value) {
        const store = this.storage.getStore();
        if (store) {
            store.data.set(key, value);
        }
    }
    /**
     * Gets the correlation ID from the current context.
     * This is a convenience method that retrieves the value associated with the configured header name.
     * @returns {string | undefined} The correlation ID, or undefined if not set.
     */
    getCorrelationId() {
        return this.get('correlationId');
    }
    /**
     * Gets the transaction ID from the current context.
     * @returns {string | undefined} The transaction ID, or undefined if not set.
     */
    getTransactionId() {
        return this.get('transactionId');
    }
    /**
     * Sets the transaction ID in the current context.
     * @param transactionId The transaction ID to set.
     */
    setTransactionId(transactionId) {
        this.set('transactionId', transactionId);
    }
    /**
     * Gets the configured HTTP header name for the correlation ID.
     * @returns {string} The header name.
     */
    getCorrelationIdHeaderName() {
        return this.correlationIdHeader;
    }
    getTransactionIdHeaderName() {
        return this.transactionIdHeader;
    }
    /**
     * Gets the tracing headers to propagate the context (e.g., W3C Trace Context).
     * This base implementation does not support trace context propagation.
     * @returns `undefined` as this feature is not implemented by default.
     */
    getTraceContextHeaders() {
        const headers = {};
        const correlationId = this.getCorrelationId();
        const transactionId = this.getTransactionId();
        if (correlationId) {
            headers[this.getCorrelationIdHeaderName()] = correlationId;
        }
        if (transactionId) {
            headers[this.getTransactionIdHeaderName()] = transactionId;
        }
        return headers;
    }
    getFilteredContext(level) {
        const fullContext = this.getAll();
        if (!this.loggingMatrix) {
            return fullContext;
        }
        const fieldsToKeep = this.loggingMatrix[level] ?? this.loggingMatrix.default;
        if (!fieldsToKeep) {
            return {};
        }
        if (fieldsToKeep.includes('*')) {
            return { ...fullContext };
        }
        const filteredContext = {};
        for (const key of fieldsToKeep) {
            if (Object.prototype.hasOwnProperty.call(fullContext, key)) {
                filteredContext[key] = fullContext[key];
            }
        }
        return filteredContext;
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * @file src/logger/Logger.ts
 * @description The core implementation of the ILogger interface.
 */
/**
 * @class Logger
 * @description The core logger implementation. It orchestrates the entire logging
 * pipeline, from argument parsing and level checking to serialization, masking,
 * and dispatching to transports.
 */
class Logger {
    level;
    name;
    transports;
    bindings;
    dependencies;
    constructor(name, transports, dependencies, options = {}) {
        this.name = name;
        this.transports = transports;
        this.dependencies = dependencies;
        this.bindings = options.bindings ?? {};
        this.level = options.level ?? 'info';
    }
    /**
     * @private
     * The core asynchronous logging method that runs the full processing pipeline.
     * It handles argument parsing, level filtering, serialization, masking,
     * and finally dispatches the processed log entry to the appropriate transports.
     * @param {LogLevel} level - The severity level of the log message.
     * @param {...any[]} args - The arguments to be logged, following the Pino-like signature (e.g., `(obj, msg, ...)` or `(msg, ...)`).
     * @returns {Promise<void>}
     */
    async _log(level, ...args) {
        if (level === 'silent') {
            return;
        }
        // Type-guarded access to weights
        const weightedLevel = level;
        const weightedThisLevel = this.level;
        if (LOG_LEVEL_WEIGHTS[weightedLevel] < LOG_LEVEL_WEIGHTS[weightedThisLevel]) {
            return;
        }
        const context = this.dependencies.contextManager.getFilteredContext(level);
        const logEntry = {
            ...context,
            ...this.bindings,
            level,
            timestamp: new Date().toISOString(),
            message: '', // Initialize message
        };
        // Extract metadata object if it's the first argument
        const firstArg = args[0];
        if (typeof firstArg === 'object' &&
            firstArg !== null &&
            !Array.isArray(firstArg)) {
            Object.assign(logEntry, firstArg);
            args.shift(); // Remove it from args
        }
        // Format message, allowing metadata message to be a format string
        const formatString = logEntry.message || args[0];
        const formatArgs = logEntry.message ? args : args.slice(1);
        if (formatString) {
            logEntry.message = util.format(formatString, ...formatArgs);
        }
        // 1. Apply custom serializers (e.g., for Error objects)
        const finalEntry = await this.dependencies.serializerRegistry.process(logEntry, this);
        // 2. Apply masking to the entire, serialized entry.
        const maskedEntry = await this.dependencies.maskingEngine.process(finalEntry);
        // Dispatch to transports
        await Promise.all(this.transports.map((transport) => {
            if (transport.isLevelEnabled(level)) {
                // The type assertion is safe here because the masking engine preserves the structure.
                return transport.log(maskedEntry);
            }
            return Promise.resolve();
        }));
    }
    /**
     * Logs a message at the 'info' level.
     * @param {...any[]} args - The arguments to log.
     */
    info(...args) {
        return this._log('info', ...args);
    }
    /**
     * Logs a message at the 'warn' level.
     * @param {...any[]} args - The arguments to log.
     */
    warn(...args) {
        return this._log('warn', ...args);
    }
    /**
     * Logs a message at the 'error' level.
     * @param {...any[]} args - The arguments to log.
     */
    error(...args) {
        return this._log('error', ...args);
    }
    /**
     * Logs a message at the 'debug' level.
     * @param {...any[]} args - The arguments to log.
     */
    debug(...args) {
        return this._log('debug', ...args);
    }
    /**
     * Logs a message at the 'trace' level.
     * @param {...any[]} args - The arguments to log.
     */
    trace(...args) {
        return this._log('trace', ...args);
    }
    /**
     * Logs a message at the 'fatal' level.
     * @param {...any[]} args - The arguments to log.
     */
    fatal(...args) {
        return this._log('fatal', ...args);
    }
    /**
     * Dynamically updates the minimum log level for this logger instance.
     * Any messages with a severity lower than the new level will be ignored.
     * @param {LogLevel} level - The new minimum log level.
     */
    setLevel(level) {
        this.level = level;
    }
    /**
     * Creates a new child logger instance that inherits the parent's configuration
     * and adds a set of persistent key-value bindings.
     * @param {Record<string, any>} bindings - Key-value pairs to add to the child logger.
     * @returns {Logger} A new logger instance with the combined bindings.
     */
    child(bindings) {
        return new Logger(this.name, this.transports, this.dependencies, {
            ...this,
            bindings: { ...this.bindings, ...bindings },
        });
    }
    /**
     * Creates a new logger instance with a `source` field bound to it.
     * @param {string} source - The name of the source (e.g., 'redis', 'AuthModule').
     * @returns {Logger} A new logger instance with the `source` binding.
     */
    withSource(source) {
        return this.child({ source });
    }
    /**
     * Creates a new logger instance with a `retention` field bound to it.
     * The provided rules object is deep-cloned to ensure immutability.
     * @param {Record<string, any>} rules - A JSON object containing the retention rules.
     * @returns {Logger} A new logger instance with the `retention` binding.
     */
    withRetention(rules) {
        const safeRules = JSON.parse(JSON.stringify(rules));
        return this.child({ retention: safeRules });
    }
    /**
     * Creates a new logger instance with a `transactionId` field bound to it.
     * @param {string} transactionId - The unique ID of the transaction.
     * @returns {Logger} A new logger instance with the `transactionId` binding.
     */
    withTransactionId(transactionId) {
        return this.child({ transactionId });
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * FILE: src/masking/MaskingEngine.ts
 * DESCRIPTION: Central engine for applying robust, secure data masking to log objects.
 */
/**
 * @class MaskingEngine
 * A central engine responsible for applying masking rules to log metadata.
 * It recursively scans objects and masks data based on key names, and can also
 * sanitize sensitive values from URL paths. Its design is "secure-by-default,"
 * allowing for runtime configuration updates that can only add (not remove) masking rules.
 */
class MaskingEngine {
    /** @private A dynamic array of sensitive field names or RegExps. */
    fieldConfigs;
    /** @private The character(s) to use for masking. */
    maskChar;
    /** @private The maximum recursion depth for masking nested objects. */
    maxDepth;
    /** @private The masking style to apply. */
    style;
    /** @private Secure regex tester with timeout. */
    regexTest;
    constructor(options) {
        this.fieldConfigs = options?.fields || [];
        this.maskChar = options?.maskChar || '******';
        this.maxDepth = options?.maxDepth ?? 3;
        this.style = options?.style ?? 'fixed';
        this.regexTest = new RegexTest({ timeout: 100 });
    }
    /**
     * Adds new sensitive fields to the masking configuration at runtime.
     * This method is "additive only" to prevent security degradation. Once a field
     * is added to the mask list, it cannot be removed during the application's lifecycle.
     *
     * @param {(string | RegExp)[]} fields - An array of new field names or RegExps to add.
     *        Duplicates are silently ignored.
     */
    addFields(fields) {
        if (!fields || fields.length === 0) {
            return;
        }
        const existingFieldsSet = new Set(this.fieldConfigs.map((f) => f.toString()));
        for (const field of fields) {
            if (!existingFieldsSet.has(field.toString())) {
                this.fieldConfigs.push(field);
                existingFieldsSet.add(field.toString()); // Update the set for the current run
            }
        }
    }
    /**
     * Processes a metadata object and applies the configured masking rules.
     * @param {Record<string, any>} meta - The metadata object to process.
     * @returns {Record<string, any>} A new object with the masked data.
     */
    async process(meta) {
        return this.maskRecursively(meta, '', 0);
    }
    /**
     * @private
     * Recursively traverses an object or array to mask data.
     * It applies two types of masking:
     * 1. **Key-based masking**: If an object key matches a rule in `fieldConfigs`, its value is masked.
     * 2. **Path-based masking**: If a string value looks like a path/URL, it's sanitized.
     *
     * @param {any} data - The data to process (can be an object, array, or primitive).
     * @param {string} currentPath - The dot-notation path of the current key.
     * @param {number} depth - The current recursion depth to prevent infinite loops.
     * @returns {any} The processed data with masking applied.
     */
    async maskRecursively(data, currentPath, depth) {
        if (depth > this.maxDepth || data === null || typeof data !== 'object') {
            return data;
        }
        if (Array.isArray(data)) {
            // For arrays, we process each item individually.
            return Promise.all(data.map((item) => this.maskRecursively(item, currentPath, depth + 1)));
        }
        const sanitizedObject = {};
        for (const key in data) {
            if (Object.prototype.hasOwnProperty.call(data, key)) {
                const value = data[key];
                const newPath = currentPath ? `${currentPath}.${key}` : key;
                if (await this.isSensitive(newPath)) {
                    sanitizedObject[key] = this.getMask(value);
                }
                else if (typeof value === 'string') {
                    sanitizedObject[key] = await this.sanitizeUrlPath(value);
                }
                else if (typeof value === 'object' && value !== null) {
                    sanitizedObject[key] = await this.maskRecursively(value, newPath, depth + 1);
                }
                else {
                    sanitizedObject[key] = value;
                }
            }
        }
        return sanitizedObject;
    }
    /**
     * @private
     * Checks if a given object key path is sensitive based on the configured rules.
     * @param {string} path - The dot-notation path of the key (e.g., "user.password").
     * @returns {Promise<boolean>} - True if the path should be masked.
     */
    async isSensitive(path) {
        for (const config of this.fieldConfigs) {
            if (typeof config === 'string') {
                if (path === config || path.endsWith(`.${config}`)) {
                    return true;
                }
            }
            else if (config instanceof RegExp) {
                // FIXME: This uses the native .test() method, which does not protect against
                // Regular Expression Denial of Service (ReDoS) attacks. The 'regex-test'
                // library was causing timeouts. This should be revisited to find a secure
                // and performant solution.
                if (config.test(path)) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * @private
     * Sanitizes a string that may represent a URL path.
     * If a segment of the path matches a sensitive field name (case-insensitively),
     * the following path segment is completely replaced with the mask character.
     *
     * @example
     * // with `fields: ['password']`
     * sanitizeUrlPath("/api/v1/password/s3cr3t-v4lu3")
     * // returns: "/api/v1/password/*****"
     *
     * @param {string} str - The string to sanitize.
     * @returns {string} The sanitized string, or the original if no sensitive keywords were found.
     */
    async sanitizeUrlPath(str) {
        // Quick check to avoid processing every single string.
        if (!str.includes('/')) {
            return str;
        }
        const parts = str.split('/');
        let modified = false;
        for (let i = 0; i < parts.length - 1; i++) {
            const currentPart = parts[i];
            const nextPart = parts[i + 1];
            let isSensitive = false;
            for (const config of this.fieldConfigs) {
                // Path sanitization should ONLY act on string keywords, not complex regex.
                if (typeof config === 'string') {
                    if (currentPart.toLowerCase() === config.toLowerCase()) {
                        isSensitive = true;
                        break;
                    }
                }
            }
            if (isSensitive && nextPart.length > 0) {
                parts[i + 1] = this.getMask(nextPart);
                modified = true;
                i++;
            }
        }
        return modified ? parts.join('/') : str;
    }
    /**
     * @private
     * Generates the appropriate mask string based on the configured style.
     * @param {any} originalValue - The original value being masked. Its length is used for 'preserve-length' style.
     * @returns {string} The generated mask string.
     */
    getMask(originalValue) {
        if (this.style === 'preserve-length') {
            const length = String(originalValue).length;
            // Use the first character of maskChar and repeat it.
            return this.maskChar.charAt(0).repeat(length > 0 ? length : 1);
        }
        // For 'fixed' style, always return the configured maskChar.
        return this.maskChar;
    }
}

/**
 * @file src/serialization/SerializerRegistry.ts
 * @description Manages and safely applies custom log object serializers.
 */
/**
 * @class SerializerRegistry
 * @description Manages and applies custom serializer functions to log metadata.
 * It ensures that serializers are executed safely, with timeouts and error handling,
 * to prevent them from destabilizing the logging pipeline.
 */
class SerializerRegistry {
    /** @private A map of field names to their corresponding serializer functions. */
    serializers;
    /** @private The timeout in milliseconds for each serializer execution. */
    timeoutMs;
    /**
     * @constructor
     * @param {SerializerRegistryOptions} [options] - Configuration options for the registry.
     */
    constructor(options) {
        this.serializers = options?.serializers || {};
        this.timeoutMs = options?.timeoutMs || 50; // Default to a 50ms timeout
        // Add a default, built-in serializer for Error objects if one isn't provided.
        if (!this.serializers['err']) {
            this.serializers['err'] = this.defaultErrorSerializer;
        }
    }
    /**
     * Processes a metadata object, applying any matching serializers.
     * @param {Record<string, unknown>} meta - The metadata object from a log call.
     * @param {ILogger} logger - A logger instance to report errors from the serialization process itself.
     * @returns {Promise<Record<string, unknown>>} A new metadata object with serialized values.
     */
    async process(meta, logger) {
        const processedMeta = { ...meta };
        for (const key in processedMeta) {
            if (Object.prototype.hasOwnProperty.call(this.serializers, key)) {
                const serializerFn = this.serializers[key];
                const valueToSerialize = processedMeta[key];
                try {
                    // Execute the serializer within the secure executor
                    const serializedValue = await this.secureExecute(serializerFn, valueToSerialize);
                    processedMeta[key] = serializedValue;
                }
                catch (error) {
                    logger.warn(`Custom serializer for key "${key}" failed or timed out.`, { error: error instanceof Error ? error.message : String(error) });
                    processedMeta[key] =
                        `[SERIALIZER_ERROR: Failed to process key '${key}']`;
                }
            }
        }
        return processedMeta;
    }
    /**
     * @private
     * Safely executes a serializer function with a timeout.
     * @param {(value: unknown) => string} serializerFn - The serializer function to execute.
     * @param {unknown} value - The value to pass to the function.
     * @returns {Promise<string>} A promise that resolves with the serialized string.
     * @throws An error if the serializer throws an exception or times out.
     */
    secureExecute(serializerFn, value) {
        return new Promise((resolve, reject) => {
            const timer = setTimeout(() => {
                reject(new Error(`Serializer function timed out after ${this.timeoutMs}ms.`));
            }, this.timeoutMs);
            try {
                // We use Promise.resolve() to handle both sync and async serializers.
                Promise.resolve(serializerFn(value))
                    .then((result) => {
                    clearTimeout(timer);
                    resolve(result);
                })
                    .catch((err) => {
                    clearTimeout(timer);
                    reject(err);
                });
            }
            catch (err) {
                clearTimeout(timer);
                reject(err);
            }
        });
    }
    /**
     * @private
     * The default serializer for Error objects. It creates a JSON string representation
     * of the error, explicitly including common properties like name, message, and stack.
     * @param {unknown} err - The value to serialize, expected to be an Error.
     * @returns {string} A JSON string representing the error.
     */
    defaultErrorSerializer(err) {
        if (!(err instanceof Error)) {
            // For non-Error objects, a simple stringify is the best we can do.
            return JSON.stringify(err);
        }
        // For Error objects, explicitly pull out known, safe properties.
        const serializedError = {
            name: err.name,
            message: err.message,
            stack: err.stack,
        };
        // Include common additional properties if they exist.
        if ('cause' in err)
            serializedError.cause = err.cause;
        if ('code' in err)
            serializedError.code = err.code;
        return JSON.stringify(serializedError, null, 2);
    }
}

/**
 * @class ConsoleTransport
 * @description A transport that writes logs to the console as a single, serialized JSON string.
 * This format is ideal for log aggregation systems that can parse JSON.
 * @extends {Transport}
 */
class ConsoleTransport extends Transport {
    /**
     * @constructor
     * @param {TransportOptions} [options] - Options for the transport, including level, formatter, and a sanitization engine.
     */
    constructor(options) {
        super(options);
    }
    /**
     * Logs a structured entry to the console as a single JSON string.
     * The entry is first formatted (if a formatter is provided) and then sanitized
     * before being written to the console.
     * @param {LogEntry} entry - The log entry to process.
     * @returns {Promise<void>}
     */
    async log(entry) {
        if (!this.isLevelEnabled(entry.level)) {
            return;
        }
        const finalObject = this.formatter ? this.formatter.format(entry) : entry;
        const logString = JSON.stringify(finalObject);
        switch (entry.level) {
            case 'fatal':
            case 'error':
                console.error(logString);
                break;
            case 'warn':
                console.warn(logString);
                break;
            default:
                console.log(logString);
                break;
        }
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * @file src/sanitization/SanitizationEngine.ts
 * @description Final security layer that sanitizes log entries before they are written by a transport.
 */
/**
 * @class SanitizationEngine
 * A security engine that makes log entries safe for printing by stripping
 * potentially malicious control characters, such as ANSI escape codes.
 * This prevents log injection attacks that could exploit terminal vulnerabilities.
 */
class SanitizationEngine {
    maskingEngine;
    /** @private This regex matches ANSI escape codes used for colors, cursor movement, etc. */
    // prettier-ignore
    // eslint-disable-next-line no-control-regex
    ansiRegex = /[\x1b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
    /**
     * @constructor
     * The engine is currently not configurable, but the constructor is in place for future enhancements.
     */
    constructor(maskingEngine) {
        this.maskingEngine = maskingEngine;
    }
    /**
     * Processes a log metadata object, sanitizing all its string values.
     * @param {Record<string, any>} meta - The metadata object to sanitize.
     * @returns {Record<string, any>} A new, sanitized metadata object.
     */
    process(meta) {
        let sanitized = this.sanitizeRecursively(meta);
        if (this.maskingEngine) {
            sanitized = this.maskingEngine.process(sanitized);
        }
        return sanitized;
    }
    /**
     * @private
     * Recursively traverses an object or array to sanitize all string values.
     * @param {any} data - The data to process.
     * @returns {any} The sanitized data.
     */
    sanitizeRecursively(data) {
        if (typeof data === 'string') {
            return data.replace(this.ansiRegex, '');
        }
        if (Array.isArray(data)) {
            return data.map((item) => this.sanitizeRecursively(item));
        }
        // Clave: Solo procesar objetos planos para no corromper instancias de clases.
        if (typeof data === 'object' &&
            data !== null &&
            data.constructor === Object) {
            const sanitizedObject = {};
            for (const key in data) {
                // hasOwnProperty sigue siendo una buena práctica aquí.
                if (Object.prototype.hasOwnProperty.call(data, key)) {
                    sanitizedObject[key] = this.sanitizeRecursively(data[key]);
                }
            }
            return sanitizedObject;
        }
        // Devuelve cualquier otro tipo de dato (números, booleans, instancias, etc.) sin modificar.
        return data;
    }
}

/**
 * @class LoggerFactory
 * @description Manages the lifecycle and configuration of all logging components.
 * An instance of this factory is created by `syntropyLog.init()` and acts as the central
 * orchestrator for creating and managing logger instances and their dependencies.
 */
class LoggerFactory {
    /** @private The manager for handling asynchronous contexts. */
    contextManager;
    /** @private The main framework instance, used as a mediator. */
    syntropyLogInstance;
    /** @private The array of transports to which logs will be dispatched. */
    transports;
    /** @private The global minimum log level for all created loggers. */
    globalLogLevel;
    /** @private The global service name, used as a default for loggers. */
    serviceName;
    /** @private The engine responsible for serializing complex objects. */
    serializerRegistry;
    /** @private The engine responsible for masking sensitive data. */
    maskingEngine;
    /** @private A pool to cache logger instances by name for performance. */
    loggerPool = new Map();
    /**
     * @constructor
     * @param {SyntropyLogConfig} config - The global configuration object.
     * @param {IContextManager} contextManager - The shared context manager instance.
     * @param {SyntropyLog} syntropyLogInstance - The main framework instance for mediation.
     * @description Initializes all core logging engines and orchestrates transport setup.
     * It follows a key principle for transport configuration:
     * - **If `config.logger.transports` is provided:** The factory trusts the user's
     *   configuration completely and uses the provided transports as-is. It is the user's
     *   responsibility to configure them correctly (e.g., adding sanitization).
     * - **If no transports are provided:** The factory creates a single, production-safe
     *   `ConsoleTransport` by default, which includes a built-in `SanitizationEngine`.
     */
    constructor(config, contextManager, syntropyLogInstance) {
        this.contextManager = contextManager;
        this.syntropyLogInstance = syntropyLogInstance;
        // Configure the context manager by passing the entire context config object.
        if (config.context) {
            this.contextManager.configure(config.context);
        }
        // Configure the HTTP manager if http instances are provided
        if (config.http?.instances) ;
        // If the user provides a specific list of transports, we use them directly.
        // We trust the user to have configured them correctly (e.g., providing a
        // SanitizationEngine to their production transports).
        if (config.logger?.transports) {
            this.transports = config.logger.transports;
        }
        else {
            // If no transports are provided, we create a safe, default production transport.
            // This transport includes a default sanitization engine.
            const sanitizationEngine = new SanitizationEngine();
            this.transports = [new ConsoleTransport({ sanitizationEngine })];
        }
        this.globalLogLevel = config.logger?.level ?? 'info';
        this.serviceName = config.logger?.serviceName ?? 'unknown-service';
        this.serializerRegistry = new SerializerRegistry({
            serializers: config.logger?.serializers,
            timeoutMs: config.logger?.serializerTimeoutMs,
        });
        this.maskingEngine = new MaskingEngine({
            fields: config.masking?.fields,
            maskChar: config.masking?.maskChar,
            maxDepth: config.masking?.maxDepth,
        });
    }
    /**
     * Retrieves a logger instance by name. If the logger does not exist, it is created
     * and cached for subsequent calls.
     * @param {string} [name='default'] - The name of the logger to retrieve.
     * @returns {ILogger} The logger instance.
     */
    getLogger(name = 'default') {
        if (this.loggerPool.has(name)) {
            return this.loggerPool.get(name);
        }
        const loggerName = name === 'default' ? this.serviceName : name;
        const dependencies = {
            contextManager: this.contextManager,
            serializerRegistry: this.serializerRegistry,
            maskingEngine: this.maskingEngine,
            syntropyLogInstance: this.syntropyLogInstance,
        };
        const logger = new Logger(loggerName, this.transports, dependencies);
        logger.level = this.globalLogLevel;
        this.loggerPool.set(name, logger);
        return logger;
    }
    /**
     * Calls the `flush` method on all configured transports to ensure buffered
     * logs are written before the application exits.
     */
    async flushAllTransports() {
        const flushPromises = this.transports.map((transport) => transport.flush().catch((err) => {
            console.error(`Error flushing transport ${transport.constructor.name}:`, err);
        }));
        await Promise.allSettled(flushPromises);
    }
}

/**
 * FILE: src/redis/RedisConnectionManager.ts
 * DESCRIPTION: Manages the lifecycle of the Redis client connection.
 */
// Type guard for single-node RedisClientType
function isRedisClientType(client) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return typeof client.ping === 'function' && !('commands' in client);
}
/**
 * @class RedisConnectionManager
 * Handles the state and lifecycle of a single native `node-redis` client.
 * It abstracts away the complexities of connection states, retries, and events,
 * providing a stable and predictable promise-based interface for connecting and disconnecting.
 */
class RedisConnectionManager {
    instanceName;
    client;
    logger;
    connectionPromise = null;
    connectionResolve = null;
    connectionReject = null;
    isConnectedAndReadyState = false;
    isQuitState = false;
    /**
     * Constructs a new RedisConnectionManager.
     * @param {RedisClientOptions | RedisClusterOptions} options - The configuration options for the native `redis` client.
     * @param {ILogger} logger - The logger instance for logging connection events.
     */
    constructor(config, logger) {
        this.logger = logger;
        this.instanceName = config.instanceName;
        this.client = this.createNativeClient(config);
        this.setupListeners();
    }
    /**
     * Creates a native Redis client based on the instance configuration mode.
     * @param config The configuration for the specific Redis instance.
     * @returns A `NodeRedisClient` (either single-node or cluster).
     */
    createNativeClient(config) {
        switch (config.mode) {
            case 'single':
            case 'sentinel': {
                // The reconnection strategy only applies to 'single' and 'sentinel' modes.
                // It is defined here so TypeScript can correctly infer that 'config' has the 'retryOptions' property.
                const reconnectStrategy = (retries) => {
                    const maxRetries = config.retryOptions?.maxRetries ?? 10;
                    if (retries > maxRetries) {
                        return new Error('Exceeded the maximum number of Redis connection retries.');
                    }
                    return Math.min(retries * 50, config.retryOptions?.retryDelay ?? 2000);
                };
                if (config.mode === 'single') {
                    return createClient({
                        url: config.url,
                        socket: {
                            reconnectStrategy,
                        },
                    });
                }
                else {
                    // An intermediate variable is created so that TypeScript correctly infers the overload.
                    const sentinelOptions = {
                        sentinels: config.sentinels,
                        name: config.name,
                        sentinelPassword: config.sentinelPassword,
                        socket: {
                            reconnectStrategy,
                        },
                    };
                    return createClient(sentinelOptions);
                }
            }
            case 'cluster': {
                // Reconnection in cluster mode is handled internally by the library.
                // The variable is explicitly typed so that TypeScript uses the correct overload of `createClient`.
                const clusterOptions = {
                    // Transforms the node configuration to the structure expected by the 'redis' library.
                    rootNodes: config.rootNodes.map((node) => ({
                        socket: { host: node.host, port: node.port },
                    })),
                };
                return createClient(clusterOptions);
            }
            default: {
                const _exhaustiveCheck = config;
                throw new Error(
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                `Unsupported Redis mode: "${_exhaustiveCheck.mode}"`); // NOSONAR
            }
        }
    }
    /**
     * Sets up all the necessary event listeners on the native Redis client
     * to manage and report on the connection's lifecycle state.
     * @private
     */
    setupListeners() {
        this.client.on('connect', () => this.logger.info(`Connection established.`));
        this.client.on('ready', () => {
            this.logger.info(`Client is ready.`);
            this.isConnectedAndReadyState = true;
            if (this.connectionResolve) {
                this.connectionResolve();
                this.connectionResolve = null;
                this.connectionReject = null;
            }
        });
        this.client.on('end', () => {
            this.logger.warn(`Connection closed.`);
            this.isConnectedAndReadyState = false;
        });
        this.client.on('error', (err) => {
            this.logger.error(`Client Error.`, { error: err });
            if (this.connectionReject) {
                this.connectionReject(err);
                this.connectionPromise = null;
                this.connectionResolve = null;
                this.connectionReject = null;
            }
        });
        this.client.on('reconnecting', () => {
            this.logger.info(`Client is reconnecting...`);
        });
    }
    /**
     * Initiates a connection to the Redis server.
     * This method is idempotent; it will not attempt to reconnect if already connected
     * or if a connection attempt is already in progress.
     * @returns {Promise<void>} A promise that resolves when the client is connected and ready, or rejects on a connection error.
     */
    connect() {
        if (this.isQuitState) {
            return Promise.reject(new Error('Client has been quit and cannot be reconnected.'));
        }
        if (this.isReady()) {
            return Promise.resolve();
        }
        if (this.connectionPromise) {
            return this.connectionPromise;
        }
        this.logger.info(`Attempting to connect...`);
        this.connectionPromise = new Promise((resolve, reject) => {
            this.connectionResolve = resolve;
            this.connectionReject = reject;
            this.client.connect().catch((err) => {
                this.logger.error(`Immediate connection attempt failed.`, {
                    error: err,
                });
                if (this.connectionReject) {
                    this.connectionReject(err);
                    this.connectionPromise = null;
                    this.connectionResolve = null;
                    this.connectionReject = null;
                }
            });
        });
        return this.connectionPromise;
    }
    /**
     * Ensures the client is connected and ready before proceeding.
     * This is the primary method that should be awaited before executing a command.
     * @returns {Promise<void>} A promise that resolves when the client is ready, or rejects if it can't connect.
     */
    ensureReady() {
        if (this.isQuitState) {
            return Promise.reject(new Error('Client has been quit. Cannot execute commands.'));
        }
        if (!this.isReady() && !this.connectionPromise) {
            this.logger.debug('ensureReady: Client not open, initiating connect.');
        }
        return this.connect();
    }
    /**
     * Gracefully closes the connection to the Redis server by calling `quit()`.
     * It also sets an internal state to prevent any further operations or reconnections.
     * @returns {Promise<void>} A promise that resolves when the client has been successfully quit.
     */
    async disconnect() {
        if (this.isQuitState) {
            this.logger.info('Quit already called. No action taken.');
            return;
        }
        if (this.connectionReject) {
            this.connectionReject(new Error('Connection aborted due to disconnect call.'));
            this.connectionPromise = null;
            this.connectionResolve = null;
            this.connectionReject = null;
        }
        this.isQuitState = true;
        this.isConnectedAndReadyState = false;
        if (this.client.isOpen) {
            this.logger.info('Attempting to quit client.');
            try {
                await this.client.quit();
            }
            catch (error) {
                this.logger.error('Error during client.quit().', { error });
                throw error;
            }
        }
        else {
            this.logger.info('Client was not open. Quit operation effectively complete.');
        }
    }
    /**
     * Retrieves the underlying native `node-redis` client instance.
     * @returns {NodeRedisClient} The native client instance.
     */
    getNativeClient() {
        return this.client;
    }
    /**
     * Checks if the client is currently connected and ready to accept commands.
     * @returns {boolean} `true` if the client is ready, `false` otherwise.
     */
    isReady() {
        return this.isConnectedAndReadyState;
    }
    /**
     * Performs a health check by sending a PING command to the server.
     * @returns {Promise<boolean>} A promise that resolves to `true` if the server responds correctly, `false` otherwise.
     */
    async isHealthy() {
        if (this.isQuitState || !this.isReady()) {
            return false;
        }
        try {
            // By calling this.ping(), we reuse the logic that correctly handles
            // single-node and cluster clients.
            const pong = await this.ping();
            this.logger.debug(`PING response: ${pong}`);
            return pong === 'PONG';
        }
        catch (error) {
            this.logger.error(`PING failed during health check.`, { error });
            return false;
        }
    }
    /**
     * Checks if the disconnect (`quit`) process has been initiated for this client.
     * @returns {boolean} `true` if `disconnect` has been called, `false` otherwise.
     */
    isQuit() {
        return this.isQuitState;
    }
    /**
     * Executes the Redis PING command.
     * Provides a fallback for cluster mode, as PING is not a standard cluster command.
     */
    async ping(message) {
        // First, we ensure the client is ready to receive commands.
        await this.ensureReady();
        // We use the type guard to check if it's a single-node or sentinel client.
        if (isRedisClientType(this.client)) {
            return this.client.ping(message);
        }
        // If it's a cluster client, we simulate the response as the library does.
        return Promise.resolve(message || 'PONG');
    }
    /**
     * Executes the Redis INFO command.
     * Provides a fallback for cluster mode.
     */
    async info(section) {
        // We ensure the client is ready.
        await this.ensureReady();
        // Again, we use the type guard.
        if (isRedisClientType(this.client)) {
            return this.client.info(section);
        }
        // The INFO command does not exist in cluster mode.
        return Promise.resolve('# INFO command is not supported in cluster mode.');
    }
    /**
     * Executes the Redis EXISTS command.
     * @param {string | string[]} keys - A single key or an array of keys to check.
     * @returns {Promise<number>} A promise that resolves with the number of existing keys.
     */
    async exists(keys) {
        await this.ensureReady();
        // The .exists() command is supported by both single-node and cluster clients.
        return this.client.exists(keys);
    }
}

/**
 * @file src/redis/RedisManager.ts
 * @description Manages the lifecycle of multiple instrumented Redis client instances.
 */
/**
 * Manages the creation, retrieval, and lifecycle of multiple `IBeaconRedis` instances
 * based on the provided configuration. It acts as a central point of access for all
 * Redis clients within an application.
 */
class RedisManager {
    instances = new Map();
    defaultInstance;
    logger;
    config;
    contextManager;
    constructor(config, logger, contextManager) {
        this.config = config;
        this.logger = logger.child({ module: 'RedisManager' });
        this.contextManager = contextManager;
    }
    init() {
        this.logger.trace('Initializing RedisManager...');
        if (!this.config ||
            !this.config.instances ||
            this.config.instances.length === 0) {
            this.logger.trace('No Redis instances to initialize.');
            return;
        }
        for (const instanceConfig of this.config.instances) {
            const connectionManager = new RedisConnectionManager(instanceConfig, this.logger);
            this.instances.set(instanceConfig.instanceName, connectionManager);
            if (instanceConfig.instanceName === this.config.default) {
                this.logger.trace(`Setting default Redis instance: ${instanceConfig.instanceName}`);
                this.defaultInstance = connectionManager;
            }
        }
        if (!this.defaultInstance && this.instances.size > 0) {
            const firstInstance = this.instances.values().next().value;
            const firstName = this.instances.keys().next().value;
            this.logger.trace(`No default Redis instance configured. Using first available instance: ${firstName}`);
            this.defaultInstance = firstInstance;
        }
    }
    getInstance(name) {
        const instanceName = name ?? this.defaultInstance?.instanceName;
        if (!instanceName) {
            throw new Error('A specific instance name was not provided and no default Redis instance is configured.');
        }
        const instance = this.instances.get(instanceName);
        if (!instance) {
            throw new Error(`Redis instance with name "${instanceName}" was not found. Please check that the name is spelled correctly in your configuration and code.`);
        }
        return instance;
    }
    /**
     * Gracefully shuts down all managed Redis connections.
     * It attempts to close all connections and waits for them to complete.
     */
    async shutdown() {
        this.logger.info('Closing all Redis connections...');
        const shutdownPromises = Array.from(this.instances.values()).map((instance) => instance.disconnect());
        await Promise.allSettled(shutdownPromises);
        this.logger.info('All Redis connections have been closed.');
    }
}

/**
 * FILE: src/utils/sanitizeConfig.ts
 * DESCRIPTION: Utilities for sanitizing the SyntropyLog configuration object.
 */
const MASK = '[CONFIG_MASKED]';
const SENSITIVE_KEYS = [
    'password',
    'token',
    'secret',
    'apikey',
    'credential',
    'pass',
    'key',
    'accesstoken',
    'refreshtoken',
    'clientsecret',
    'sentinelpassword',
    'sasl',
];
/**
 * @private
 * A helper function to detect if a value is a special class instance
 * (like a Transport or an Adapter) that should not be deeply cloned or sanitized.
 * This is crucial to preserve methods and internal state of user-provided instances.
 * @param {any} value - The value to check.
 * @returns {value is Transport | IHttpClientAdapter | IBrokerAdapter} True if the value is a special instance.
 */
function isSpecialInstance(value) {
    if (value instanceof Transport) {
        return true;
    }
    // Duck-typing for adapters: if it has the core method, we treat it as an adapter.
    if (typeof value === 'object' &&
        value !== null &&
        (typeof value.request === 'function' ||
            typeof value.publish === 'function')) {
        return true;
    }
    return false;
}
/**
 * Recursively sanitizes a configuration object for safe logging.
 * It masks values for keys that are known to be sensitive and redacts credentials from URLs.
 * It intelligently skips special class instances (Transports, Adapters) to preserve their methods.
 * @param {T} config - The configuration object to sanitize.
 * @returns {T} A new, sanitized configuration object.
 */
function sanitizeConfig(config) {
    // If the object is a special instance (like a Transport or Adapter), return it without processing.
    if (isSpecialInstance(config)) {
        return config;
    }
    if (config === null || typeof config !== 'object') {
        return config;
    }
    if (Array.isArray(config)) {
        return config.map((item) => sanitizeConfig(item));
    }
    const sanitized = {};
    const sensitiveLower = SENSITIVE_KEYS.map((k) => k.toLowerCase());
    for (const key in config) {
        if (Object.prototype.hasOwnProperty.call(config, key)) {
            const lowerKey = key.toLowerCase();
            const value = config[key];
            if (sensitiveLower.includes(lowerKey)) {
                sanitized[key] = MASK;
            }
            else if ((lowerKey.includes('url') || lowerKey.includes('uri')) &&
                typeof value === 'string') {
                // Redact user:pass from connection strings.
                sanitized[key] = value.replace(/(?<=:\/\/)[^:]+:[^@]+@/, `${MASK}@`);
            }
            else if (typeof value === 'object' &&
                value !== null &&
                !(value instanceof RegExp)) {
                // The recursive call will also respect special instances.
                sanitized[key] = sanitizeConfig(value);
            }
            else {
                sanitized[key] = value;
            }
        }
    }
    return sanitized;
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * @file src/http/InstrumentedHttpClient.ts
 * @description This class is the heart of the HTTP instrumentation architecture.
 * It wraps any adapter that complies with `IHttpClientAdapter` and adds a centralized
 * layer of instrumentation (logging, context, timers).
 */
/**
 * @class InstrumentedHttpClient
 * @description Wraps an `IHttpClientAdapter` to provide automatic logging,
 * context propagation, and timing for all HTTP requests.
 */
class InstrumentedHttpClient {
    adapter;
    logger;
    contextManager;
    config;
    instanceName;
    instrumentorOptions;
    /**
     * @constructor
     * @param {IHttpClientAdapter} adapter - The underlying HTTP client adapter (e.g., AxiosAdapter).
     * @param {ILogger} logger - The logger instance for this client.
     * @param {IContextManager} contextManager - The manager for handling asynchronous contexts.
     * @param {HttpClientInstanceConfig} config - The configuration for this specific instance.
     */
    constructor(adapter, logger, contextManager, config) {
        this.adapter = adapter;
        this.logger = logger;
        this.contextManager = contextManager;
        this.config = config;
        this.instanceName = config.instanceName;
        // Extract instrumentation options from the main config for clarity.
        this.instrumentorOptions = {
            logRequestHeaders: this.config.logging?.logRequestHeaders,
            logRequestBody: this.config.logging?.logRequestBody,
            logSuccessHeaders: this.config.logging?.logSuccessHeaders,
            logSuccessBody: this.config.logging?.logSuccessBody,
            logLevel: {
                onRequest: this.config.logging?.onRequest,
                onSuccess: this.config.logging?.onSuccess,
                onError: this.config.logging?.onError,
            },
        };
    }
    /**
     * The single public method. It executes an HTTP request through the wrapped
     * adapter, applying all instrumentation logic.
     * @template T The expected type of the response data.
     * @param {AdapterHttpRequest} request - The generic HTTP request to execute.
     * @returns {Promise<AdapterHttpResponse<T>>} A promise that resolves with the normalized response.
     * @throws {AdapterHttpError | Error} Throws the error from the adapter, which is re-thrown after being logged.
     */
    async request(request) {
        const startTime = Date.now();
        if (!request.headers) {
            request.headers = {};
        }
        // 1. Inject context into headers based on the configuration.
        if (this.config.propagate?.includes('*')) {
            // Wildcard behavior: Propagate the entire context map.
            const contextObject = this.contextManager.getAll();
            for (const key in contextObject) {
                if (Object.prototype.hasOwnProperty.call(contextObject, key)) {
                    const value = contextObject[key];
                    if (typeof value === 'string') {
                        request.headers[key] = value;
                    }
                }
            }
        }
        else if (this.config.propagate && Array.isArray(this.config.propagate)) {
            // New behavior: Propagate only specified context keys.
            for (const key of this.config.propagate) {
                const value = this.contextManager.get(key);
                if (typeof value === 'string') {
                    request.headers[key] = value;
                }
            }
        }
        else if (this.config.propagateFullContext) {
            // DEPRECATED: Propagate the entire context map.
            const contextObject = this.contextManager.getAll();
            for (const key in contextObject) {
                if (Object.prototype.hasOwnProperty.call(contextObject, key)) {
                    const value = contextObject[key];
                    if (typeof value === 'string') {
                        request.headers[key] = value;
                    }
                }
            }
        }
        // Always propagate correlation and transaction IDs, as they are fundamental.
        const correlationId = this.contextManager.getCorrelationId();
        if (correlationId) {
            request.headers[this.contextManager.getCorrelationIdHeaderName()] =
                correlationId;
        }
        const transactionId = this.contextManager.getTransactionId();
        if (transactionId) {
            request.headers[this.contextManager.getTransactionIdHeaderName()] =
                transactionId;
        }
        // 2. Log the start of the request.
        this.logRequestStart(request);
        try {
            // 3. Delegate execution to the adapter.
            const response = await this.adapter.request(request);
            const durationMs = Date.now() - startTime;
            // 4. Log the successful completion of the request.
            this.logRequestSuccess(request, response, durationMs);
            return response;
        }
        catch (error) {
            const durationMs = Date.now() - startTime;
            // 5. Log the failure of the request.
            this.logRequestFailure(request, error, durationMs);
            // 6. Re-throw the error so the user's code can handle it.
            throw error;
        }
    }
    /**
     * @private
     * Logs the start of an HTTP request, respecting the configured options.
     * @param {AdapterHttpRequest} request - The outgoing request.
     */
    logRequestStart(request) {
        const logLevel = this.instrumentorOptions.logLevel?.onRequest ?? 'info';
        const logPayload = {
            method: request.method,
            url: request.url,
        };
        if (this.instrumentorOptions.logRequestHeaders) {
            logPayload.headers = request.headers;
        }
        if (this.instrumentorOptions.logRequestBody) {
            logPayload.body = request.body;
        }
        this.logger[logLevel](logPayload, 'Starting HTTP request');
    }
    /**
     * @private
     * Logs the successful completion of an HTTP request.
     * @template T
     * @param {AdapterHttpRequest} request - The original request.
     * @param {AdapterHttpResponse<T>} response - The received response.
     * @param {number} durationMs - The total duration of the request in milliseconds.
     */
    logRequestSuccess(request, response, durationMs) {
        const logLevel = this.instrumentorOptions.logLevel?.onSuccess ?? 'info';
        const logPayload = {
            statusCode: response.statusCode,
            url: request.url,
            method: request.method,
            durationMs,
        };
        if (this.instrumentorOptions.logSuccessHeaders) {
            logPayload.headers = response.headers;
        }
        if (this.instrumentorOptions.logSuccessBody) {
            logPayload.body = response.data;
        }
        this.logger[logLevel](logPayload, 'HTTP response received');
    }
    /**
     * @private
     * Logs the failure of an HTTP request.
     * @param {AdapterHttpRequest} request - The original request.
     * @param {unknown} error - The error that was thrown.
     * @param {number} durationMs - The total duration of the request until failure.
     */
    logRequestFailure(request, error, durationMs) {
        const logLevel = this.instrumentorOptions.logLevel?.onError ?? 'error';
        // Use the normalized adapter error if available for richer logging.
        if (error && error.isAdapterError) {
            const adapterError = error;
            const logPayload = {
                err: adapterError, // The logger's serializer will handle this.
                url: request.url,
                method: request.method,
                durationMs,
                response: adapterError.response
                    ? {
                        statusCode: adapterError.response.statusCode,
                        headers: adapterError.response.headers,
                        body: adapterError.response.data,
                    }
                    : 'No response',
            };
            this.logger[logLevel](logPayload, 'HTTP request failed');
        }
        else {
            // If it's an unexpected error, log it as well.
            this.logger[logLevel]({ err: error, url: request.url, method: request.method, durationMs }, 'HTTP request failed with an unexpected error');
        }
    }
}

/**
 * FILE: src/http/HttpManager.ts
 * @description Manages the lifecycle and creation of multiple instrumented HTTP client instances.
 */
/**
 * @class HttpManager
 * @description Manages the creation and retrieval of multiple instrumented HTTP client instances.
 * It reads the configuration, creates an `InstrumentedHttpClient` for each defined
 * instance by wrapping the user-provided adapter, and provides a way to retrieve them.
 */
class HttpManager {
    /** @private A map storing the created instrumented client instances by name. */
    instances = new Map();
    /** @private The logger instance for the manager itself. */
    logger;
    /** @private A reference to the context manager for dependency injection. */
    contextManager;
    /** @private The global application configuration. */
    config;
    /** @private The name of the default HTTP client instance. */
    defaultInstance;
    constructor(config, logger, contextManager) {
        this.config = config;
        this.logger = logger.child({ module: 'HttpManager' });
        this.contextManager = contextManager;
    }
    init() {
        this.logger.trace('Initializing HttpManager...');
        if (!this.config.instances || this.config.instances.length === 0) {
            this.logger.debug('HttpManager initialized, but no HTTP client instances were defined.');
            return;
        }
        for (const instanceConfig of this.config.instances) {
            try {
                const client = new InstrumentedHttpClient(instanceConfig.adapter, this.logger, this.contextManager, instanceConfig);
                this.instances.set(instanceConfig.instanceName, client);
                this.logger.info(`HTTP client instance "${instanceConfig.instanceName}" created successfully via adapter.`);
                if (instanceConfig.isDefault) {
                    if (this.defaultInstance) {
                        this.logger.warn(`Multiple default HTTP instances defined. Overwriting previous default "${this.defaultInstance.instanceName}" with "${instanceConfig.instanceName}".`);
                    }
                    this.logger.trace(`Setting default HTTP instance: ${instanceConfig.instanceName}`);
                    this.defaultInstance = client;
                }
            }
            catch (error) {
                this.logger.error(`Failed to create HTTP client instance "${instanceConfig.instanceName}"`, { error });
            }
        }
        if (!this.defaultInstance && this.instances.size > 0) {
            const firstInstance = this.instances.values().next().value;
            const firstName = this.instances.keys().next().value;
            this.logger.trace(`No default HTTP instance configured. Using first available instance: ${firstName}`);
            this.defaultInstance = firstInstance;
        }
    }
    /**
     * Retrieves a managed and instrumented HTTP client instance by its name.
     * The returned client has a unified API via its `.request()` method.
     * @param {string} name - The name of the HTTP client instance to retrieve.
     * @returns {InstrumentedHttpClient} The requested client instance.
     * @throws {Error} If no instance with the given name is found.
     */
    getInstance(name) {
        const instanceName = name ?? this.defaultInstance?.instanceName;
        if (!instanceName) {
            throw new Error('A specific instance name was not provided and no default HTTP instance is configured.');
        }
        const instance = this.instances.get(instanceName);
        if (!instance) {
            throw new Error(`HTTP client instance with name "${instanceName}" was not found. Check your configuration.`);
        }
        return instance;
    }
    /**
     * Clears all managed HTTP client instances. This is a simple cleanup operation.
     */
    async shutdown() {
        this.logger.info('Shutting down HTTP clients.');
        this.instances.clear();
        // HTTP clients do not require explicit shutdown, so we just clear the map.
        return Promise.resolve();
    }
}

/**
 * @class InstrumentedBrokerClient
 * @description Wraps a user-provided broker adapter to automatically handle
 * logging, context propagation, and distributed tracing.
 */
class InstrumentedBrokerClient {
    adapter;
    logger;
    contextManager;
    config;
    instanceName;
    /**
     * @constructor
     * @param {IBrokerAdapter} adapter - The concrete broker adapter implementation (e.g., for RabbitMQ, Kafka).
     * @param {ILogger} logger - The logger instance for this client.
     * @param {IContextManager} contextManager - The manager for handling asynchronous contexts.
     * @param {BrokerInstanceConfig} config - The configuration for this specific instance.
     */
    constructor(adapter, logger, contextManager, config) {
        this.adapter = adapter;
        this.logger = logger;
        this.contextManager = contextManager;
        this.config = config;
        this.instanceName = config.instanceName;
    }
    /**
     * Establishes a connection to the broker, wrapping the adapter's connect
     * method with logging.
     * @returns {Promise<void>}
     */
    async connect() {
        this.logger.info('Connecting to broker...');
        await this.adapter.connect();
        this.logger.info('Successfully connected to broker.');
    }
    /**
     * Disconnects from the broker, wrapping the adapter's disconnect method
     * with logging.
     * @returns {Promise<void>}
     */
    async disconnect() {
        this.logger.info('Disconnecting from broker...');
        await this.adapter.disconnect();
        this.logger.info('Successfully disconnected from broker.');
    }
    /**
     * Publishes a message, automatically injecting the current `correlation-id`
     * from the active context into the message headers.
     * @param {string} topic - The destination topic or routing key for the message.
     * @param {BrokerMessage} message - The message to be published. The `correlation-id`
     * will be added to its headers if not present.
     * @returns {Promise<void>}
     */
    async publish(topic, message) {
        if (!message.headers) {
            message.headers = {};
        }
        // 1. Inject context into headers based on the configuration.
        if (this.config.propagate?.includes('*')) {
            // Wildcard behavior: Propagate the entire context map.
            const contextObject = this.contextManager.getAll();
            for (const key in contextObject) {
                if (Object.prototype.hasOwnProperty.call(contextObject, key)) {
                    const value = contextObject[key];
                    if (typeof value === 'string' || Buffer.isBuffer(value)) {
                        message.headers[key] = value;
                    }
                }
            }
        }
        else if (this.config.propagate && Array.isArray(this.config.propagate)) {
            // New behavior: Propagate only specified context keys.
            for (const key of this.config.propagate) {
                const value = this.contextManager.get(key);
                if (typeof value === 'string' || Buffer.isBuffer(value)) {
                    message.headers[key] = value;
                }
            }
        }
        else if (this.config.propagateFullContext) {
            // DEPRECATED: Propagate the entire context map.
            const contextObject = this.contextManager.getAll();
            for (const key in contextObject) {
                if (Object.prototype.hasOwnProperty.call(contextObject, key)) {
                    const value = contextObject[key];
                    if (typeof value === 'string' || Buffer.isBuffer(value)) {
                        // Note: Broker headers typically support string | Buffer.
                        message.headers[key] = value;
                    }
                }
            }
        }
        // Always propagate correlation and transaction IDs, as they are fundamental.
        const correlationId = this.contextManager.getCorrelationId();
        if (correlationId) {
            message.headers[this.contextManager.getCorrelationIdHeaderName()] =
                correlationId;
        }
        const transactionId = this.contextManager.getTransactionId();
        if (transactionId) {
            message.headers[this.contextManager.getTransactionIdHeaderName()] =
                transactionId;
        }
        this.logger.info({ topic, messageId: message.headers?.['id'] }, 'Publishing message...');
        await this.adapter.publish(topic, message);
        this.logger.info({ topic, messageId: message.headers?.['id'] }, 'Message published successfully.');
    }
    /**
     * Subscribes to a topic. It wraps the user's message handler to automatically
     * create a new asynchronous context for each incoming message. If a `correlation-id`
     * is found in the message headers, it is used to initialize the new context.
     * @param {string} topic - The topic or queue to subscribe to.
     * @param {MessageHandler} handler - The user-provided function to process incoming messages.
     * @returns {Promise<void>}
     */
    async subscribe(topic, handler) {
        this.logger.info({ topic }, 'Subscribing to topic...');
        // Wrap the user's handler to implement automatic context propagation.
        const instrumentedHandler = async (message, controls) => {
            // Restore context from all headers found in the message.
            // This is more robust as it doesn't assume which headers are present.
            await this.contextManager.run(async () => {
                if (message.headers) {
                    for (const key in message.headers) {
                        this.contextManager.set(key, message.headers[key]);
                    }
                }
                const correlationId = this.contextManager.getCorrelationId();
                this.logger.info({ topic, correlationId }, 'Received message.');
                // Also wrap the lifecycle controls to add logging for ack/nack actions.
                const instrumentedControls = {
                    ack: async () => {
                        await controls.ack();
                        this.logger.debug({ topic, correlationId }, 'Message acknowledged (ack).');
                    },
                    nack: async (requeue) => {
                        await controls.nack(requeue);
                        this.logger.warn({ topic, correlationId, requeue }, 'Message negatively acknowledged (nack).');
                    },
                };
                // Execute the original user-provided handler.
                await handler(message, instrumentedControls);
            });
        };
        await this.adapter.subscribe(topic, instrumentedHandler);
        this.logger.info({ topic }, 'Successfully subscribed to topic.');
    }
}

/**
 * FILE: src/brokers/BrokerManager.ts
 * DESCRIPTION:
 * Manages the lifecycle and creation of multiple instrumented broker client instances,
 * following the same pattern as HttpManager and RedisManager.
 */
/**
 * @class BrokerManager
 * @description Manages the lifecycle and creation of multiple instrumented broker client instances.
 * It reads the configuration, creates an `InstrumentedBrokerClient` for each defined
 * instance, and provides a way to retrieve them and shut them down gracefully.
 */
class BrokerManager {
    instances = new Map();
    defaultInstance;
    logger;
    config;
    contextManager;
    constructor(config, logger, contextManager) {
        this.config = config;
        this.logger = logger.child({ module: 'BrokerManager' });
        this.contextManager = contextManager;
    }
    async init() {
        this.logger.trace('Initializing BrokerManager...');
        if (!this.config.instances || this.config.instances.length === 0) {
            this.logger.debug('BrokerManager initialized, but no broker instances were defined.');
            return;
        }
        const creationPromises = this.config.instances.map(async (instanceConfig) => {
            try {
                const client = new InstrumentedBrokerClient(instanceConfig.adapter, this.logger, this.contextManager, instanceConfig);
                await client.connect(); // Connect is likely async
                this.instances.set(instanceConfig.instanceName, client);
                this.logger.info(`Broker client instance "${instanceConfig.instanceName}" created and connected successfully.`);
                if (instanceConfig.instanceName === this.config.default) {
                    this.logger.trace(`Setting default broker instance: ${instanceConfig.instanceName}`);
                    this.defaultInstance = client;
                }
            }
            catch (error) {
                this.logger.error(`Failed to create broker instance "${instanceConfig.instanceName}":`, error);
            }
        });
        await Promise.all(creationPromises);
        if (!this.defaultInstance && this.instances.size > 0) {
            const firstInstance = this.instances.values().next().value;
            const firstName = this.instances.keys().next().value;
            this.logger.trace(`No default broker instance configured. Using first available instance: ${firstName}`);
            this.defaultInstance = firstInstance;
        }
    }
    getInstance(name) {
        const instanceName = name ?? this.defaultInstance?.instanceName;
        if (!instanceName) {
            throw new Error('A specific instance name was not provided and no default Broker instance is configured.');
        }
        const instance = this.instances.get(instanceName);
        if (!instance) {
            throw new Error(`Broker client instance with name "${instanceName}" was not found. Check your configuration.`);
        }
        return instance;
    }
    async shutdown() {
        this.logger.info('Disconnecting all broker clients...');
        const shutdownPromises = Array.from(this.instances.values()).map((instance) => instance.disconnect());
        await Promise.allSettled(shutdownPromises);
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
class LifecycleManager extends EventEmitter {
    state = 'NOT_INITIALIZED';
    config;
    contextManager;
    loggerFactory;
    redisManager;
    httpManager;
    brokerManager;
    serializerRegistry;
    maskingEngine;
    logger = null;
    syntropyFacade;
    constructor(syntropyFacade) {
        super();
        this.syntropyFacade = syntropyFacade;
        // Initialize properties here to satisfy TypeScript's strict checks
        this.config = {};
        this.serializerRegistry = new SerializerRegistry({});
        this.maskingEngine = new MaskingEngine({});
    }
    getState() {
        return this.state;
    }
    async init(config) {
        if (this.state !== 'NOT_INITIALIZED') {
            this.logger?.warn(`LifecycleManager.init() called while in state '${this.state}'. Ignoring subsequent call.`);
            return;
        }
        this.state = 'INITIALIZING';
        try {
            const parsedConfig = syntropyLogConfigSchema.parse(config);
            const sanitizedConfig = sanitizeConfig(parsedConfig);
            this.config = sanitizedConfig;
            this.contextManager = new ContextManager(this.config.loggingMatrix);
            if (this.config.context) {
                this.contextManager.configure(this.config.context);
            }
            this.serializerRegistry = new SerializerRegistry({
                serializers: this.config.logger?.serializers,
                timeoutMs: this.config.logger?.serializerTimeoutMs,
            });
            this.maskingEngine = new MaskingEngine(this.config.masking);
            this.loggerFactory = new LoggerFactory(this.config, this.contextManager, this.syntropyFacade);
            const logger = this.loggerFactory.getLogger('syntropylog-main');
            this.logger = logger;
            if (this.config.redis) {
                this.redisManager = new RedisManager(this.config.redis, logger.withSource('redis-manager'), this.contextManager);
            }
            if (this.config.http) {
                this.httpManager = new HttpManager(this.config.http, logger.withSource('http-manager'), this.contextManager);
                this.httpManager.init();
            }
            if (this.config.brokers) {
                this.brokerManager = new BrokerManager(this.config.brokers, logger.withSource('broker-manager'), this.contextManager);
                await this.brokerManager.init();
            }
            await logger.info('SyntropyLog framework initialized successfully.');
            this.state = 'READY';
            this.emit('ready');
        }
        catch (error) {
            this.state = 'ERROR';
            this.emit('error', error);
            if (error instanceof ZodError) {
                console.error('[SyntropyLog] Configuration validation failed:', error.errors);
            }
            else {
                console.error('[SyntropyLog] Failed to initialize framework:', error);
            }
            throw error;
        }
    }
    async shutdown() {
        if (this.state !== 'READY') {
            return;
        }
        this.state = 'SHUTTING_DOWN';
        this.emit('shutting_down');
        try {
            this.logger?.info('Shutting down SyntropyLog framework...');
            const shutdownPromises = [
                this.redisManager?.shutdown(),
                this.brokerManager?.shutdown(),
                this.httpManager?.shutdown(),
            ].filter(Boolean);
            await Promise.allSettled(shutdownPromises);
            this.logger?.info('All managers have been shut down.');
            this.state = 'SHUTDOWN';
            this.emit('shutdown');
        }
        catch (error) {
            this.state = 'ERROR';
            this.emit('error', error);
        }
    }
    ensureReady() {
        if (this.state !== 'READY') {
            throw new Error(`SyntropyLog is not ready. Current state: '${this.state}'. Ensure init() has completed successfully by listening for the 'ready' event.`);
        }
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * @file src/SyntropyLog.ts
 * @description The main public-facing singleton class for the SyntropyLog framework.
 * This class acts as a Facade, providing a simple and clean API surface
 * while delegating all complex lifecycle and orchestration work to the internal
 * LifecycleManager.
 */
/**
 * @class SyntropyLog
 * @description The main public entry point for the framework. It follows the
 * Singleton pattern and acts as an EventEmitter to report on its lifecycle,
 * proxying events from its internal LifecycleManager.
 */
class SyntropyLog extends EventEmitter {
    static instance;
    lifecycleManager;
    constructor() {
        super();
        this.lifecycleManager = new LifecycleManager(this);
        // Proxy events from the lifecycle manager to the public facade
        this.lifecycleManager.on('ready', () => this.emit('ready'));
        this.lifecycleManager.on('error', (err) => this.emit('error', err));
        this.lifecycleManager.on('shutting_down', () => this.emit('shutting_down'));
        this.lifecycleManager.on('shutdown', () => this.emit('shutdown'));
    }
    static getInstance() {
        if (!SyntropyLog.instance) {
            SyntropyLog.instance = new SyntropyLog();
        }
        return SyntropyLog.instance;
    }
    getState() {
        return this.lifecycleManager.getState();
    }
    async init(config) {
        return this.lifecycleManager.init(config);
    }
    async shutdown() {
        return this.lifecycleManager.shutdown();
    }
    getLogger(name = 'default') {
        if (!this.lifecycleManager.loggerFactory) {
            throw new Error('Logger Factory not available.');
        }
        return this.lifecycleManager.loggerFactory.getLogger(name);
    }
    getRedis(name) {
        this.lifecycleManager.ensureReady();
        return this.lifecycleManager.redisManager.getInstance(name);
    }
    getHttp(name) {
        this.lifecycleManager.ensureReady();
        return this.lifecycleManager.httpManager.getInstance(name);
    }
    getBroker(name) {
        this.lifecycleManager.ensureReady();
        return this.lifecycleManager.brokerManager.getInstance(name);
    }
    getContextManager() {
        this.lifecycleManager.ensureReady();
        return this.lifecycleManager.contextManager;
    }
    getConfig() {
        this.lifecycleManager.ensureReady();
        return this.lifecycleManager.config;
    }
    getFilteredContext(level) {
        this.lifecycleManager.ensureReady();
        return this.lifecycleManager.contextManager.getFilteredContext(level);
    }
    getMasker() {
        if (!this.lifecycleManager.maskingEngine) {
            throw new Error('MaskingEngine not available.');
        }
        return this.lifecycleManager.maskingEngine;
    }
    getSerializer() {
        if (!this.lifecycleManager.serializerRegistry) {
            throw new Error('SerializerRegistry not available.');
        }
        return this.lifecycleManager.serializerRegistry;
    }
    _resetForTesting() {
        // This needs to re-create the lifecycle manager to properly reset state
        this.lifecycleManager.removeAllListeners();
        this.lifecycleManager = new LifecycleManager(this);
        this.removeAllListeners();
        this.lifecycleManager.on('ready', () => this.emit('ready'));
        this.lifecycleManager.on('error', (err) => this.emit('error', err));
        this.lifecycleManager.on('shutting_down', () => this.emit('shutting_down'));
        this.lifecycleManager.on('shutdown', () => this.emit('shutdown'));
    }
}
/** The singleton instance of the SyntropyLog framework. */
const syntropyLog = SyntropyLog.getInstance();

/**
 * @file src/logger/transports/BaseConsolePrettyTransport.ts
 * @description An abstract base class for console transports that provide colored, human-readable output.
 */
/**
 * @class BaseConsolePrettyTransport
 * @description Provides common functionality for "pretty" console transports,
 * including color handling and console method selection. Subclasses must
 * implement the `formatLogString` method to define the final output format.
 * @extends {Transport}
 */
class BaseConsolePrettyTransport extends Transport {
    chalk;
    constructor(options) {
        super(options);
        // Chalk v4 is used directly, not instantiated.
        this.chalk = chalk;
    }
    /**
     * The core log method. It handles common logic and delegates specific
     * formatting to the subclass.
     * @param {LogEntry} entry - The log entry to process.
     * @returns {Promise<void>}
     */
    async log(entry) {
        if (!this.isLevelEnabled(entry.level)) {
            return;
        }
        // Apply the formatter first if it exists.
        const finalObject = this.formatter ? this.formatter.format(entry) : entry;
        // Let the subclass format the final string.
        const logString = this.formatLogString(finalObject);
        // Select the appropriate console method based on the log level.
        const consoleMethod = this.getConsoleMethod(finalObject.level);
        consoleMethod(logString);
    }
    /**
     * Determines which console method to use based on the log level.
     * @param {LogLevel} level - The log level.
     * @returns {Function} The corresponding console method (e.g., console.log).
     */
    getConsoleMethod(level
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ) {
        switch (level) {
            case 'fatal':
            case 'error':
                return console.error;
            case 'warn':
                return console.warn;
            default:
                return console.log;
        }
    }
}

/**
 * @class PrettyConsoleTransport
 * @description A transport that writes logs to the console in a human-readable, colorful format.
 * Ideal for use in development environments.
 * @extends {BaseConsolePrettyTransport}
 */
class PrettyConsoleTransport extends BaseConsolePrettyTransport {
    levelColorMap;
    /**
     * @constructor
     * @param {TransportOptions} [options] - Options for the transport, such as level or a formatter.
     */
    constructor(options) {
        super(options);
        this.levelColorMap = {
            fatal: this.chalk.bgRed.white.bold,
            error: this.chalk.red.bold,
            warn: this.chalk.yellow.bold,
            info: this.chalk.blue.bold,
            debug: this.chalk.green,
            trace: this.chalk.gray,
        };
    }
    /**
     * Formats the log object into a pretty, human-readable string.
     * @param {Record<string, any>} logObject - The log object to format.
     * @returns {string} The formatted string.
     */
    formatLogString(logObject) {
        const { timestamp, level, service, msg, ...rest } = logObject;
        const colorizer = this.levelColorMap[level] ||
            this.chalk.white;
        // Format the main log line
        const time = this.chalk.gray(new Date(timestamp).toLocaleTimeString());
        const levelString = colorizer(`[${level.toUpperCase()}]`);
        const serviceString = this.chalk.cyan(`(${service})`);
        const message = msg;
        let logString = `${time} ${levelString} ${serviceString}: ${message}`;
        // Handle additional metadata, ensuring it's not empty
        const metaKeys = Object.keys(rest);
        if (metaKeys.length > 0) {
            // Use a more subtle color for metadata
            const metaString = this.chalk.gray(JSON.stringify(rest, null, 2));
            logString += `\n${metaString}`;
        }
        return logString;
    }
}

/**
 * @class CompactConsoleTransport
 * A transport that writes logs to the console in a compact, single-line format
 * for metadata, optimized for developer productivity.
 * @extends {BaseConsolePrettyTransport}
 */
class CompactConsoleTransport extends BaseConsolePrettyTransport {
    levelColorMap;
    /**
     * @constructor
     * @param {TransportOptions} [options] - Options for the transport, such as level or a formatter.
     */
    constructor(options) {
        super(options);
        this.levelColorMap = {
            fatal: this.chalk.bgRed.white.bold,
            error: this.chalk.red.bold,
            warn: this.chalk.yellow.bold,
            info: this.chalk.cyan.bold, // Using cyan for better contrast in compact view.
            debug: this.chalk.green,
            trace: this.chalk.gray,
        };
    }
    /**
     * Formats the log object into a compact, human-readable string.
     * @param {Record<string, any>} logObject - The log object to format.
     * @returns {string} The formatted string.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    formatLogString(logObject) {
        const { timestamp, level, service, msg, ...rest } = logObject;
        const colorizer = this.levelColorMap[level] ||
            this.chalk.white;
        const time = this.chalk.gray(new Date(timestamp).toLocaleTimeString());
        const levelString = colorizer(`[${level.toUpperCase()}]`);
        const serviceString = this.chalk.blue(`(${service})`);
        const message = msg;
        let logString = `${time} ${levelString} ${serviceString}: ${message}`;
        // Format metadata into a single, compact line.
        const metaKeys = Object.keys(rest);
        if (metaKeys.length > 0) {
            const metaString = metaKeys
                .map((key) => {
                const value = rest[key];
                // Simple stringify for objects/arrays in metadata.
                const formattedValue = typeof value === 'object' && value !== null
                    ? JSON.stringify(value)
                    : value;
                return `${this.chalk.dim(key)}=${this.chalk.gray(formattedValue)}`;
            })
                .join(' ');
            // Append metadata on a new, indented line for clarity.
            logString += `\n  ${this.chalk.dim('└─')} ${metaString}`;
        }
        return logString;
    }
}

/**
 * @class ClassicConsoleTransport
 * A transport that writes logs to the console in a classic single-line format,
 * reminiscent of traditional Java logging frameworks.
 * @extends {BaseConsolePrettyTransport}
 */
class ClassicConsoleTransport extends BaseConsolePrettyTransport {
    levelColorMap;
    /**
     * @constructor
     * @param {TransportOptions} [options] - Options for the transport, such as level or a formatter.
     */
    constructor(options) {
        super(options);
        this.levelColorMap = {
            fatal: this.chalk.bgRed.white.bold,
            error: this.chalk.red.bold,
            warn: this.chalk.yellow.bold,
            info: this.chalk.green, // Using green for info in this style
            debug: this.chalk.blue,
            trace: this.chalk.gray,
        };
    }
    /**
     * @private
     * Formats a date object into a 'YYYY-MM-DD HH:mm:ss' string.
     * @param {string} ts - The ISO timestamp string to format.
     * @returns {string} The formatted timestamp.
     */
    formatTimestamp(ts) {
        const date = new Date(ts);
        const YYYY = date.getFullYear();
        const MM = String(date.getMonth() + 1).padStart(2, '0');
        const DD = String(date.getDate()).padStart(2, '0');
        const HH = String(date.getHours()).padStart(2, '0');
        const min = String(date.getMinutes()).padStart(2, '0');
        const ss = String(date.getSeconds()).padStart(2, '0');
        return `${YYYY}-${MM}-${DD} ${HH}:${min}:${ss}`;
    }
    /**
     * Formats the log object into a classic, single-line string.
     * @param {Record<string, any>} logObject - The log object to format.
     * @returns {string} The formatted string.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    formatLogString(logObject) {
        const { timestamp, level, service, msg, context, ...rest } = logObject;
        const colorizer = this.levelColorMap[level] ||
            this.chalk.white;
        // 1. Format the timestamp.
        const timeStr = this.formatTimestamp(timestamp);
        // 2. Format the level, padded to a fixed width for alignment.
        const levelStr = colorizer(level.toUpperCase().padEnd(5));
        // 3. Format the service name.
        const serviceStr = this.chalk.magenta(`[${service}]`);
        // 4. Combine context and other metadata and format it.
        const allMeta = { ...context, ...rest };
        const metaKeys = Object.keys(allMeta);
        let metaStr = '';
        if (metaKeys.length > 0) {
            metaStr = this.chalk.dim(' [' +
                metaKeys
                    .map((key) => `${key}=${JSON.stringify(allMeta[key])}`)
                    .join(' ') +
                ']');
        }
        // 5. The main log message.
        const message = msg;
        // Assemble the final string, ensuring metadata is placed correctly.
        const logString = `${timeStr} ${levelStr} ${serviceStr}${metaStr} :: ${message}`;
        return logString;
    }
}

/**
 * @class SpyTransport
 * A transport designed for testing. It captures log entries in memory,
 * allowing you to make assertions on what has been logged.
 * @extends {Transport}
 */
class SpyTransport extends Transport {
    entries = [];
    /**
     * @constructor
     * @param {TransportOptions} [options] - Options for the transport, such as level.
     */
    constructor(options) {
        super(options);
    }
    /**
     * Stores the log entry in an in-memory array.
     * @param {LogEntry} entry - The log entry to capture.
     * @returns {Promise<void>}
     */
    async log(entry) {
        this.entries.push(entry);
    }
    /**
     * Returns all log entries captured by this transport.
     * @returns {LogEntry[]} A copy of all captured log entries.
     */
    getEntries() {
        return [...this.entries];
    }
    /**
     * Finds log entries where the properties match the given predicate.
     * Note: This performs a shallow comparison on the entry's properties.
     * @param {Partial<LogEntry> | ((entry: LogEntry) => boolean)} predicate - An object with properties to match or a function that returns true for matching entries.
     * @returns {LogEntry[]} An array of matching log entries.
     */
    findEntries(predicate) {
        if (typeof predicate === 'function') {
            // If the predicate is a function, use it directly with filter.
            return this.entries.filter(predicate);
        }
        // If the predicate is an object, perform a shallow property comparison.
        return this.entries.filter((entry) => {
            return Object.keys(predicate).every((key) => {
                const k = key;
                return predicate[k] === entry[k];
            });
        });
    }
    /**
     * Clears all captured log entries. Call this in your test setup
     * (e.g., `beforeEach`) to ensure test isolation.
     * @returns {void}
     */
    clear() {
        this.entries = [];
    }
    /**
     * Returns the first log entry that was captured.
     * @returns {LogEntry | undefined} The first entry, or undefined if none were captured.
     */
    getFirstEntry() {
        return this.entries[0];
    }
    /**
     * Returns the most recent log entry that was captured.
     * @returns {LogEntry | undefined} The last entry, or undefined if none were captured.
     */
    getLastEntry() {
        return this.entries[this.entries.length - 1];
    }
}

export { ClassicConsoleTransport, CompactConsoleTransport, ConsoleTransport, MaskingEngine, PrettyConsoleTransport, SanitizationEngine, SpyTransport, SyntropyLog, Transport, syntropyLog };
//# sourceMappingURL=index.mjs.map
